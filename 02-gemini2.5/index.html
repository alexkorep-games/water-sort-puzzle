<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Liquid Sort Puzzle</title>
    <style>
        :root {
            --tube-width: 60px;
            --tube-height: 240px;
            --liquid-height: 60px; /* --tube-height / capacity */
            --tube-border-radius: 10px;
            --tube-bottom-radius: 30px;
            --animation-speed: 0.3s;
        }

        body {
            font-family: sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #f0f0f0;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background: linear-gradient(135deg, #6e8efb, #a777e3); /* Calming gradient */
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            max-width: 95%;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 600px; /* Limit width of info bar */
            margin-bottom: 20px;
            color: white;
            font-size: 1.2em;
            font-weight: bold;
            padding: 0 10px;
        }

        .tubes-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            padding: 10px;
            max-width: 100%;
        }

        .tube {
            width: var(--tube-width);
            height: var(--tube-height);
            border: 3px solid #ccc;
            border-bottom-left-radius: var(--tube-bottom-radius);
            border-bottom-right-radius: var(--tube-bottom-radius);
            border-top-left-radius: var(--tube-border-radius);
            border-top-right-radius: var(--tube-border-radius);
            background-color: rgba(255, 255, 255, 0.3);
            position: relative;
            overflow: hidden;
            cursor: pointer;
            transition: transform var(--animation-speed) ease, box-shadow var(--animation-speed) ease;
            display: flex;
            flex-direction: column-reverse; /* Stack liquids from bottom */
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .tube.selected {
            transform: translateY(-15px) scale(1.05);
            border-color: #ffeb3b; /* Yellow highlight */
            box-shadow: 0 6px 15px rgba(255, 235, 59, 0.5);
        }

        .liquid {
            width: 100%;
            height: var(--liquid-height);
            transition: background-color var(--animation-speed) ease, height var(--animation-speed) ease;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.7em; /* Just for debugging color names if needed */
            color: white;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-top: 10px;
        }

        button {
            padding: 10px 20px;
            font-size: 1em;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            background-color: #8e44ad;
            color: white;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        button:hover {
            background-color: #9b59b6;
        }
        button:active {
            transform: scale(0.95);
        }
        button:disabled {
             background-color: #bdc3c7;
             cursor: not-allowed;
        }

        .win-message {
            position: fixed; /* Use fixed to overlay */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 180, 0, 0.9);
            color: white;
            padding: 30px 50px;
            border-radius: 15px;
            font-size: 2em;
            font-weight: bold;
            text-align: center;
            z-index: 1000;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
            animation: fadeIn 0.5s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, -60%); }
            to { opacity: 1; transform: translate(-50%, -50%); }
        }

        /* Basic responsiveness */
        @media (max-width: 600px) {
            :root {
                --tube-width: 50px;
                --tube-height: 200px;
                --liquid-height: 50px;
            }
             .game-info {
                font-size: 1em;
             }
             button {
                padding: 8px 15px;
                font-size: 0.9em;
             }
             .win-message {
                 font-size: 1.5em;
                 padding: 20px 30px;
             }
        }
         @media (max-width: 400px) {
            :root {
                --tube-width: 45px;
                --tube-height: 180px;
                --liquid-height: 45px;
            }
            .tubes-container {
                gap: 15px;
            }
         }

    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-info">
            <span id="level">Level: 1</span>
            <span id="moves">Moves: 0</span>
        </div>
        <div class="tubes-container" id="tubesContainer">
            <!-- Tubes will be generated here by JavaScript -->
        </div>
        <div class="controls">
            <button id="undoBtn">Undo</button>
            <button id="restartBtn">Restart</button>
        </div>
        <div id="winMessage" class="win-message" style="display: none;">
            Level Complete! ðŸŽ‰
        </div>
    </div>

    <script>
        const tubesContainer = document.getElementById('tubesContainer');
        const movesSpan = document.getElementById('moves');
        const undoBtn = document.getElementById('undoBtn');
        const restartBtn = document.getElementById('restartBtn');
        const winMessageDiv = document.getElementById('winMessage');
        const levelSpan = document.getElementById('level');

        const TUBE_CAPACITY = 4;
        const COLORS = {
            red: '#e74c3c',
            blue: '#3498db',
            green: '#2ecc71',
            yellow: '#f1c40f',
            purple: '#9b59b6',
            orange: '#e67e22',
            pink: '#fd79a8',
            cyan: '#00cec9'
        };
        const COLOR_NAMES = Object.keys(COLORS);

        let level = 1;
        let tubes = []; // Array of arrays, representing tubes and their colors bottom-to-top
        let selectedTubeIndex = -1;
        let moves = 0;
        let history = []; // To store game states for undo
        let gameWon = false;

        // --- Level Definitions ---
        const levels = [
            // Level 1: Simple introductory level
            [
                ['blue', 'red', 'blue', 'red'],
                ['red', 'blue', 'red', 'blue'],
                [],
                []
            ],
            // Level 2: Slightly more complex
            [
                ['green', 'blue', 'red', 'red'],
                ['green', 'blue', 'green', 'blue'],
                ['red', 'green', 'blue', 'red'],
                [],
                []
            ],
             // Level 3: Introduce more colors
            [
                ['blue', 'green', 'yellow', 'red'],
                ['yellow', 'green', 'red', 'blue'],
                ['green', 'yellow', 'red', 'blue'],
                ['red', 'blue', 'yellow', 'green'],
                [],
                []
            ],
            // Level 4: More tubes, similar colors
             [
                ['orange', 'purple', 'blue', 'orange'],
                ['green', 'red', 'green', 'blue'],
                ['purple', 'orange', 'red', 'green'],
                ['blue', 'red', 'purple', 'green'],
                ['red', 'blue', 'purple', 'orange'],
                [],
                []
            ]
            // Add more levels here following the same structure
        ];

        // --- Core Game Logic ---

        function getLevelData(levelNum) {
            const index = levelNum - 1;
            if (index >= 0 && index < levels.length) {
                // Return a deep copy to avoid modifying the original level data
                return JSON.parse(JSON.stringify(levels[index]));
            } else {
                // Default to last level or handle appropriately
                console.warn(`Level ${levelNum} not found. Loading last level.`);
                level = levels.length; // Adjust current level variable
                 levelSpan.textContent = `Level: ${level}`;
                return JSON.parse(JSON.stringify(levels[levels.length - 1]));
            }
        }


        function initGame(levelNum) {
            console.log(`Initializing Level ${levelNum}`);
            tubes = getLevelData(levelNum);
            selectedTubeIndex = -1;
            moves = 0;
            history = []; // Clear history
            gameWon = false;
            winMessageDiv.style.display = 'none'; // Hide win message
            levelSpan.textContent = `Level: ${levelNum}`;

            saveState(); // Save the initial state for undo
            renderTubes();
            updateMovesDisplay();
            updateUndoButton();
        }

        function renderTubes() {
            tubesContainer.innerHTML = ''; // Clear previous tubes
            tubes.forEach((tubeData, index) => {
                const tubeElement = document.createElement('div');
                tubeElement.classList.add('tube');
                tubeElement.dataset.index = index; // Store index for click handling

                tubeData.forEach(color => {
                    const liquidSegment = document.createElement('div');
                    liquidSegment.classList.add('liquid');
                    liquidSegment.style.backgroundColor = COLORS[color] || '#cccccc'; // Default color if not found
                    // Optional: Show color name for debugging
                    // liquidSegment.textContent = color;
                    tubeElement.appendChild(liquidSegment);
                });

                 // Add empty spaces visually (optional, helps visualize capacity)
                const emptySpaces = TUBE_CAPACITY - tubeData.length;
                for (let i = 0; i < emptySpaces; i++) {
                    const emptySegment = document.createElement('div');
                    emptySegment.classList.add('liquid');
                    emptySegment.style.height = `var(--liquid-height)`;
                    emptySegment.style.backgroundColor = 'transparent'; // Make empty slots invisible
                    tubeElement.appendChild(emptySegment);
                }


                if (index === selectedTubeIndex) {
                    tubeElement.classList.add('selected');
                }

                tubeElement.addEventListener('click', handleTubeClick);
                tubesContainer.appendChild(tubeElement);
            });
        }

        function handleTubeClick(event) {
            if (gameWon) return; // Don't allow moves after winning

            const clickedIndex = parseInt(event.currentTarget.dataset.index);

            if (selectedTubeIndex === -1) {
                // First click: Select source tube
                if (tubes[clickedIndex].length > 0) { // Can only select non-empty tubes
                    selectedTubeIndex = clickedIndex;
                    renderTubes(); // Re-render to show selection
                }
            } else {
                // Second click: Select destination tube or deselect
                if (clickedIndex === selectedTubeIndex) {
                    // Clicked the same tube again: Deselect
                    selectedTubeIndex = -1;
                    renderTubes();
                } else {
                    // Attempt to pour
                    if (canPour(selectedTubeIndex, clickedIndex)) {
                        saveState(); // Save state *before* making the move
                        doPour(selectedTubeIndex, clickedIndex);
                        moves++;
                        updateMovesDisplay();
                        selectedTubeIndex = -1; // Deselect after pour
                        renderTubes();
                        updateUndoButton(); // Update undo button state after move
                        checkWinCondition();
                    } else {
                        // Invalid move - maybe add visual feedback later (e.g., shake)
                        console.log("Invalid move");
                        selectedTubeIndex = -1; // Deselect if move is invalid
                        renderTubes(); // Re-render to remove selection highlight
                    }
                }
            }
        }

        function getTopColor(tube) {
            return tube.length > 0 ? tube[tube.length - 1] : null;
        }

        function canPour(sourceIndex, destIndex) {
            const sourceTube = tubes[sourceIndex];
            const destTube = tubes[destIndex];

            if (sourceTube.length === 0) return false; // Cannot pour from empty tube
            if (destTube.length >= TUBE_CAPACITY) return false; // Cannot pour into full tube

            const topColorSource = getTopColor(sourceTube);
            const topColorDest = getTopColor(destTube);

            // Can pour if destination is empty OR top colors match
            return topColorDest === null || topColorSource === topColorDest;
        }

        function doPour(sourceIndex, destIndex) {
            const sourceTube = tubes[sourceIndex];
            const destTube = tubes[destIndex];
            const colorToMove = getTopColor(sourceTube);

            if (!colorToMove) return; // Should not happen if canPour is checked, but good practice

            // Find how many blocks of the same color are at the top of the source tube
            let pourAmount = 0;
            for (let i = sourceTube.length - 1; i >= 0; i--) {
                if (sourceTube[i] === colorToMove) {
                    pourAmount++;
                } else {
                    break; // Stop if a different color is encountered
                }
            }

            // Limit pour amount by available space in destination tube
            const availableSpace = TUBE_CAPACITY - destTube.length;
            pourAmount = Math.min(pourAmount, availableSpace);

            // Perform the transfer
            for (let i = 0; i < pourAmount; i++) {
                destTube.push(sourceTube.pop());
            }
             // console.log(`Poured ${pourAmount} of ${colorToMove} from ${sourceIndex} to ${destIndex}`);
        }

        function checkWinCondition() {
            if (gameWon) return; // Already won

            for (const tube of tubes) {
                if (tube.length > 0 && tube.length < TUBE_CAPACITY) {
                    // Tube is partially filled, cannot be a win state
                    return;
                }
                if (tube.length === TUBE_CAPACITY) {
                    // Tube is full, check if all colors are the same
                    const firstColor = tube[0];
                    for (let i = 1; i < tube.length; i++) {
                        if (tube[i] !== firstColor) {
                            // Found a different color, not a win state
                            return;
                        }
                    }
                }
                // Empty tubes (tube.length === 0) are valid in a win state
            }

            // If we reach here, all non-empty tubes are full of a single color
            console.log("Win condition met!");
            gameWon = true;
            winMessageDiv.style.display = 'block';
            // Automatically load next level after a short delay? Or require click?
             setTimeout(() => {
                 level++;
                 initGame(level);
             }, 2000); // Go to next level after 2 seconds
        }

        function updateMovesDisplay() {
            movesSpan.textContent = `Moves: ${moves}`;
        }

        // --- Undo Functionality ---

        function saveState() {
            // Save a deep copy of the current state
            history.push(JSON.parse(JSON.stringify({ tubes: tubes, moves: moves })));
            // Limit history size if needed (e.g., keep last 50 moves)
            // if (history.length > 50) history.shift();
        }

        function undoMove() {
            if (gameWon) return; // Cannot undo after winning
            if (history.length > 1) { // Need at least the initial state + one move to undo
                history.pop(); // Remove the current state
                const previousState = history[history.length - 1]; // Get the state before the last move

                // Restore the previous state (deep copy)
                tubes = JSON.parse(JSON.stringify(previousState.tubes));
                moves = previousState.moves;

                selectedTubeIndex = -1; // Reset selection
                renderTubes();
                updateMovesDisplay();
                updateUndoButton();
                winMessageDiv.style.display = 'none'; // Hide win message if it was shown erroneously
                gameWon = false; // Ensure game isn't marked as won
            } else {
                console.log("Cannot undo further.");
            }
        }

        function updateUndoButton() {
            undoBtn.disabled = history.length <= 1 || gameWon; // Disable if only initial state left or game won
        }


        // --- Event Listeners ---
        restartBtn.addEventListener('click', () => initGame(level));
        undoBtn.addEventListener('click', undoMove);

        // --- Initial Game Load ---
        window.onload = () => initGame(level);

    </script>
</body>
</html>