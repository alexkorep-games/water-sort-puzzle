<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Color Liquid Sort Puzzle</title>
    <style>
      :root {
        --tube-width: 60px;
        --tube-height: 240px;
        --liquid-height: 60px; /* --tube-height / capacity */
        --tube-border-radius: 10px;
        --tube-bottom-radius: 30px;
        --animation-speed: 0.3s;
      }

      body {
        font-family: sans-serif;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        background-color: #f0f0f0;
        margin: 0;
        padding: 20px;
        box-sizing: border-box;
        background: linear-gradient(
          135deg,
          #6e8efb,
          #a777e3
        ); /* Calming gradient */
      }

      .game-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px;
        background-color: rgba(255, 255, 255, 0.1);
        border-radius: 15px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        max-width: 95%;
      }

      .game-info {
        display: flex;
        justify-content: space-between;
        width: 100%;
        max-width: 700px;
        margin-bottom: 20px;
        color: white;
        font-size: 1.2em;
        font-weight: bold;
        padding: 0 10px;
      }

      .tubes-container {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 20px;
        margin-bottom: 20px;
        padding: 10px;
        max-width: 100%;
      }

      .tube {
        width: var(--tube-width);
        height: var(--tube-height);
        border: 3px solid #ccc;
        border-bottom-left-radius: var(--tube-bottom-radius);
        border-bottom-right-radius: var(--tube-bottom-radius);
        border-top-left-radius: var(--tube-border-radius);
        border-top-right-radius: var(--tube-border-radius);
        background-color: rgba(255, 255, 255, 0.3);
        position: relative;
        overflow: hidden;
        cursor: pointer;
        transition: transform var(--animation-speed) ease,
          box-shadow var(--animation-speed) ease;
        display: flex;
        flex-direction: column-reverse; /* Stack liquids from bottom */
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      }

      .tube.selected {
        transform: translateY(-15px) scale(1.05);
        border-color: #ffeb3b; /* Yellow highlight */
        box-shadow: 0 6px 15px rgba(255, 235, 59, 0.5);
      }

      .liquid {
        width: 100%;
        height: var(--liquid-height);
        transition: background-color var(--animation-speed) ease,
          height var(--animation-speed) ease;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 0.7em;
        color: white;
        text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
      }

      .controls {
        display: flex;
        gap: 15px;
        margin-top: 10px;
        align-items: center;
        flex-wrap: wrap; /* Allow wrapping */
        justify-content: center; /* Center controls when wrapped */
      }

      .controls label {
        color: white;
        margin-right: -5px;
        font-weight: bold;
        font-size: 0.9em;
      }

      .controls select {
        padding: 8px 10px;
        font-size: 0.9em;
        border-radius: 8px;
        border: 1px solid #ccc;
        background-color: #fdfdfd;
        cursor: pointer;
        min-width: 80px;
        margin-bottom: 5px; /* Add margin for wrapped state */
      }

      button {
        padding: 10px 20px;
        font-size: 1em;
        cursor: pointer;
        border: none;
        border-radius: 8px;
        background-color: #8e44ad;
        color: white;
        transition: background-color 0.2s ease, transform 0.1s ease;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        margin-bottom: 5px; /* Add margin for wrapped state */
      }

      button:hover {
        background-color: #9b59b6;
      }
      button:active {
        transform: scale(0.95);
      }
      button:disabled {
        background-color: #bdc3c7;
        cursor: not-allowed;
      }

      .win-message {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(0, 180, 0, 0.9);
        color: white;
        padding: 30px 50px;
        border-radius: 15px;
        font-size: 2em;
        font-weight: bold;
        text-align: center;
        z-index: 1000;
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        animation: fadeIn 0.5s ease-out;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translate(-50%, -60%);
        }
        to {
          opacity: 1;
          transform: translate(-50%, -50%);
        }
      }

      /* Basic responsiveness */
      @media (max-width: 600px) {
        :root {
          --tube-width: 50px;
          --tube-height: 200px;
          --liquid-height: 50px;
        }
        .game-info {
          font-size: 1em;
        }
        .controls label {
          font-size: 0.8em;
          margin-right: 5px;
        }
        .controls select {
          padding: 6px 8px;
          font-size: 0.8em;
        }
        button {
          padding: 8px 15px;
          font-size: 0.9em;
        }
        .win-message {
          font-size: 1.5em;
          padding: 20px 30px;
        }
      }
      @media (max-width: 400px) {
        :root {
          --tube-width: 45px;
          --tube-height: 180px;
          --liquid-height: 45px;
        }
        .tubes-container {
          gap: 15px;
        }
      }
    </style>
  </head>
  <body>
    <div class="game-container">
      <div class="game-info">
        <span id="levelInfo">Level: 1</span>
        <span id="moves">Moves: 0</span>
      </div>
      <div class="tubes-container" id="tubesContainer">
        <!-- Tubes will be generated here by JavaScript -->
      </div>
      <div class="controls">
        <label for="levelSelect">Difficulty:</label>
        <!-- Changed label -->
        <select id="levelSelect"></select>
        <button id="undoBtn">Undo</button>
        <button id="restartBtn">Restart</button>
        <button id="newGameBtn">New Random</button>
        <!-- Button to explicitly get a new random layout -->
      </div>
      <div id="winMessage" class="win-message" style="display: none">
        Level Complete! ðŸŽ‰
      </div>
    </div>

    <script>
      const tubesContainer = document.getElementById("tubesContainer");
      const movesSpan = document.getElementById("moves");
      const undoBtn = document.getElementById("undoBtn");
      const restartBtn = document.getElementById("restartBtn");
      const newGameBtn = document.getElementById("newGameBtn"); // New button ref
      const winMessageDiv = document.getElementById("winMessage");
      const levelInfoSpan = document.getElementById("levelInfo");
      const levelSelect = document.getElementById("levelSelect");

      const TUBE_CAPACITY = 4;
      const MIN_COLORS = 2; // Minimum colors for the easiest level
      const EMPTY_TUBES = 2; // How many empty tubes to add
      const SHUFFLE_MOVES_MULTIPLIER = 25; // How many random moves per color to shuffle

      const COLORS = {
        red: "#e74c3c",
        blue: "#3498db",
        green: "#2ecc71",
        yellow: "#f1c40f",
        purple: "#9b59b6",
        orange: "#e67e22",
        pink: "#fd79a8",
        cyan: "#00cec9",
        lime: "#a2e041",
        teal: "#48c9b0",
        brown: "#a0522d",
        grey: "#95a5a6",
        // Add more colors if needed for higher difficulties
      };
      const COLOR_NAMES = Object.keys(COLORS);
      const MAX_DIFFICULTY = COLOR_NAMES.length; // Max difficulty is number of available colors

      let currentDifficulty = 1; // Start at difficulty 1
      let tubes = [];
      let selectedTubeIndex = -1;
      let moves = 0;
      let history = [];
      let gameWon = false;
      let currentLevelSeed = null; // Store the initial state of the random level for restart

      // --- Level Generation ---

      /**
       * Generates a random, solvable level configuration.
       * @param {number} numColors - Number of distinct colors to use.
       * @param {number} capacity - Capacity of each tube.
       * @param {number} numEmptyTubes - Number of empty tubes to include.
       * @returns {Array<Array<string>>} - The generated level data (array of tubes).
       */
      function generateRandomLevelData(numColors, capacity, numEmptyTubes) {
        console.log(
          `Generating level with ${numColors} colors, capacity ${capacity}, ${numEmptyTubes} empty tubes.`
        );
        const numTubes = numColors + numEmptyTubes;
        const availableColors = [...COLOR_NAMES]; // Copy available colors

        // Shuffle available colors to pick from them randomly
        for (let i = availableColors.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [availableColors[i], availableColors[j]] = [
            availableColors[j],
            availableColors[i],
          ];
        }

        // Select the colors for this level
        const levelColors = availableColors.slice(0, numColors);

        // 1. Create the solved state
        let initialState = [];
        for (const color of levelColors) {
          const fullTube = Array(capacity).fill(color);
          initialState.push(fullTube);
        }
        for (let i = 0; i < numEmptyTubes; i++) {
          initialState.push([]);
        }

        // 2. Shuffle the solved state by performing random valid moves
        let shuffledState = JSON.parse(JSON.stringify(initialState)); // Deep copy
        const totalShuffleMoves = numColors * SHUFFLE_MOVES_MULTIPLIER; // Number of moves proportional to complexity
        let movesMade = 0;

        // Helper functions for shuffling (operate on the temporary state)
        const getTopColorShuffle = (tube) =>
          tube.length > 0 ? tube[tube.length - 1] : null;
        const canPourShuffle = (sourceIdx, destIdx, state) => {
          const sourceTube = state[sourceIdx];
          const destTube = state[destIdx];
          if (!sourceTube || !destTube) return false; // Check if tubes exist
          if (sourceTube.length === 0) return false;
          if (destTube.length >= capacity) return false;
          const topSource = getTopColorShuffle(sourceTube);
          const topDest = getTopColorShuffle(destTube);
          return topDest === null || topSource === topDest;
        };
        const doPourShuffle = (sourceIdx, destIdx, state) => {
          const sourceTube = state[sourceIdx];
          const destTube = state[destIdx];
          const colorToMove = getTopColorShuffle(sourceTube);
          if (!colorToMove) return false;

          let pourAmount = 0;
          for (let i = sourceTube.length - 1; i >= 0; i--) {
            if (sourceTube[i] === colorToMove) pourAmount++;
            else break;
          }
          const availableSpace = capacity - destTube.length;
          pourAmount = Math.min(pourAmount, availableSpace);

          if (pourAmount > 0) {
            for (let i = 0; i < pourAmount; i++) {
              destTube.push(sourceTube.pop());
            }
            return true; // Pour happened
          }
          return false; // No pour happened
        };

        for (let i = 0; i < totalShuffleMoves; i++) {
          const sourceIndex = Math.floor(Math.random() * numTubes);
          let destIndex = Math.floor(Math.random() * numTubes);
          // Ensure source and destination are different
          while (destIndex === sourceIndex) {
            destIndex = Math.floor(Math.random() * numTubes);
          }

          if (canPourShuffle(sourceIndex, destIndex, shuffledState)) {
            if (doPourShuffle(sourceIndex, destIndex, shuffledState)) {
              movesMade++;
            }
          }
        }

        console.log(
          `Shuffling complete after attempting ${totalShuffleMoves} moves (${movesMade} successful).`
        );

        // Final check: Ensure not accidentally solved
        let isSolved = true;
        for (const tube of shuffledState) {
          if (tube.length > 0 && tube.length < capacity) {
            isSolved = false;
            break;
          }
          if (tube.length === capacity) {
            const firstColor = tube[0];
            for (let k = 1; k < tube.length; k++) {
              if (tube[k] !== firstColor) {
                isSolved = false;
                break;
              }
            }
          }
          if (!isSolved) break;
        }

        if (isSolved && numColors > 0) {
          console.log("Shuffle resulted in solved state, reshuffling...");
          // Recursive call - careful about potential infinite loops on very simple cases, but unlikely here
          return generateRandomLevelData(numColors, capacity, numEmptyTubes);
        }

        return shuffledState;
      }

      // --- Core Game Logic ---

      function getLevelData(difficultyLevel) {
        // Determine parameters based on difficulty
        const numColors = Math.min(
          MAX_DIFFICULTY,
          Math.max(MIN_COLORS, difficultyLevel)
        );
        const numTubes = numColors + EMPTY_TUBES;

        return generateRandomLevelData(numColors, TUBE_CAPACITY, EMPTY_TUBES);
      }

      function initGame(difficulty, forceNew = false) {
        console.log(`Initializing Difficulty ${difficulty}`);
        currentDifficulty = difficulty;

        if (forceNew || currentLevelSeed === null) {
          tubes = getLevelData(currentDifficulty);
          currentLevelSeed = JSON.parse(JSON.stringify(tubes)); // Store this specific generated layout
        } else {
          // Restarting the *same* random level
          tubes = JSON.parse(JSON.stringify(currentLevelSeed));
        }

        selectedTubeIndex = -1;
        moves = 0;
        history = []; // Clear history
        gameWon = false;
        winMessageDiv.style.display = "none"; // Hide win message

        levelInfoSpan.textContent = `Difficulty: ${currentDifficulty}`; // Update level display text
        levelSelect.value = currentDifficulty; // Sync dropdown with the current difficulty

        saveState(); // Save the initial state for undo
        renderTubes();
        updateMovesDisplay();
        updateUndoButton();
      }

      // --- Rendering and Interaction (Mostly Unchanged) ---

      function renderTubes() {
        tubesContainer.innerHTML = ""; // Clear previous tubes
        tubes.forEach((tubeData, index) => {
          const tubeElement = document.createElement("div");
          tubeElement.classList.add("tube");
          tubeElement.dataset.index = index; // Store index for click handling

          // Render liquids from bottom up
          tubeData.forEach((color) => {
            const liquidSegment = document.createElement("div");
            liquidSegment.classList.add("liquid");
            liquidSegment.style.backgroundColor = COLORS[color] || "#cccccc";
            tubeElement.appendChild(liquidSegment);
          });

          // Fill remaining space visually
          const emptySpaces = TUBE_CAPACITY - tubeData.length;
          for (let i = 0; i < emptySpaces; i++) {
            const emptySegment = document.createElement("div");
            emptySegment.classList.add("liquid");
            emptySegment.style.height = `var(--liquid-height)`; // Use variable height
            emptySegment.style.backgroundColor = "transparent";
            tubeElement.appendChild(emptySegment); // Add empty segments visually
          }

          if (index === selectedTubeIndex) {
            tubeElement.classList.add("selected");
          }

          tubeElement.addEventListener("click", handleTubeClick);
          tubesContainer.appendChild(tubeElement);
        });
      }

      function handleTubeClick(event) {
        if (gameWon) return;

        const clickedIndex = parseInt(event.currentTarget.dataset.index);

        if (selectedTubeIndex === -1) {
          if (tubes[clickedIndex].length > 0) {
            selectedTubeIndex = clickedIndex;
            renderTubes();
          }
        } else {
          if (clickedIndex === selectedTubeIndex) {
            selectedTubeIndex = -1;
            renderTubes();
          } else {
            if (canPour(selectedTubeIndex, clickedIndex)) {
              saveState();
              doPour(selectedTubeIndex, clickedIndex);
              moves++;
              updateMovesDisplay();
              selectedTubeIndex = -1;
              renderTubes();
              updateUndoButton();
              checkWinCondition();
            } else {
              console.log("Invalid move");
              selectedTubeIndex = -1;
              renderTubes();
            }
          }
        }
      }

      function getTopColor(tube) {
        return tube.length > 0 ? tube[tube.length - 1] : null;
      }

      function canPour(sourceIndex, destIndex) {
        const sourceTube = tubes[sourceIndex];
        const destTube = tubes[destIndex];
        if (sourceTube.length === 0) return false;
        if (destTube.length >= TUBE_CAPACITY) return false;
        const topColorSource = getTopColor(sourceTube);
        const topColorDest = getTopColor(destTube);
        return topColorDest === null || topColorSource === topColorDest;
      }

      function doPour(sourceIndex, destIndex) {
        const sourceTube = tubes[sourceIndex];
        const destTube = tubes[destIndex];
        const colorToMove = getTopColor(sourceTube);
        if (!colorToMove) return;

        let pourAmount = 0;
        for (let i = sourceTube.length - 1; i >= 0; i--) {
          if (sourceTube[i] === colorToMove) pourAmount++;
          else break;
        }
        const availableSpace = TUBE_CAPACITY - destTube.length;
        pourAmount = Math.min(pourAmount, availableSpace);

        for (let i = 0; i < pourAmount; i++) {
          destTube.push(sourceTube.pop());
        }
      }

      function checkWinCondition() {
        if (gameWon) return;

        for (const tube of tubes) {
          if (tube.length > 0 && tube.length < TUBE_CAPACITY) return;
          if (tube.length === TUBE_CAPACITY) {
            const firstColor = tube[0];
            for (let i = 1; i < tube.length; i++) {
              if (tube[i] !== firstColor) return;
            }
          }
        }

        console.log("Win condition met!");
        gameWon = true;
        winMessageDiv.textContent = `Difficulty ${currentDifficulty} Complete! ðŸŽ‰`; // Show difficulty
        winMessageDiv.style.display = "block";
        updateUndoButton();

        setTimeout(() => {
          let nextDifficulty = currentDifficulty + 1;
          if (nextDifficulty > MAX_DIFFICULTY) {
            console.log("Completed max difficulty!");
            winMessageDiv.textContent = `All difficulties complete! ðŸŽ‰`;
            // Optional: Stay on max difficulty, or loop back?
            // Let's just stay on max for now and force a new generation
            nextDifficulty = MAX_DIFFICULTY;
            initGame(nextDifficulty, true); // Force new generation for the max level
          } else {
            initGame(nextDifficulty, true); // Move to next difficulty, force new generation
          }
        }, 2000);
      }

      function updateMovesDisplay() {
        movesSpan.textContent = `Moves: ${moves}`;
      }

      // --- Undo Functionality (Unchanged) ---

      function saveState() {
        history.push(
          JSON.parse(JSON.stringify({ tubes: tubes, moves: moves }))
        );
      }

      function undoMove() {
        if (gameWon) return;
        if (history.length > 1) {
          history.pop();
          const previousState = history[history.length - 1];
          tubes = JSON.parse(JSON.stringify(previousState.tubes));
          moves = previousState.moves;
          selectedTubeIndex = -1;
          renderTubes();
          updateMovesDisplay();
          updateUndoButton();
          winMessageDiv.style.display = "none";
          gameWon = false;
        } else {
          console.log("Cannot undo further.");
        }
      }

      function updateUndoButton() {
        undoBtn.disabled = history.length <= 1 || gameWon;
      }

      // --- Level Selector Population ---
      function populateLevelSelector() {
        levelSelect.innerHTML = "";
        // Populate based on difficulty, up to MAX_DIFFICULTY
        for (let i = 1; i <= MAX_DIFFICULTY; i++) {
          const option = document.createElement("option");
          option.value = i;
          option.textContent = `Level ${i}`; // Display as Level 1, Level 2...
          levelSelect.appendChild(option);
        }
        // Ensure MIN_COLORS is selectable if MAX_DIFFICULTY is somehow smaller
        if (MIN_COLORS > MAX_DIFFICULTY && MAX_DIFFICULTY > 0) {
          levelSelect.value = MAX_DIFFICULTY;
        } else if (MAX_DIFFICULTY === 0) {
          // Handle edge case where no colors are defined?
          const option = document.createElement("option");
          option.value = 0;
          option.textContent = `No Levels`;
          levelSelect.appendChild(option);
          levelSelect.disabled = true; // Disable selector if no levels possible
        }
      }

      // --- Event Listeners ---
      // Restart button now restarts the *current* random layout
      restartBtn.addEventListener("click", () =>
        initGame(currentDifficulty, false)
      ); // false = don't force new generation

      // New Game button explicitly generates a new layout for the current difficulty
      newGameBtn.addEventListener("click", () =>
        initGame(currentDifficulty, true)
      ); // true = force new generation

      undoBtn.addEventListener("click", undoMove);

      levelSelect.addEventListener("change", (event) => {
        const selectedDifficulty = parseInt(event.target.value);
        currentLevelSeed = null; // Clear seed when changing difficulty
        initGame(selectedDifficulty, true); // Force new generation when difficulty changes
      });

      // --- Initial Game Load ---
      window.onload = () => {
        populateLevelSelector();
        initGame(currentDifficulty, true); // Initial load forces generation
      };
    </script>
  </body>
</html>
