<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Color Liquid Sort Puzzle - Shuffled</title>
    <style>
      :root {
        --tube-width: 60px;
        --tube-height: 240px;
        --liquid-height: 60px; /* --tube-height / capacity */
        --tube-border-radius: 10px;
        --tube-bottom-radius: 30px;
        --animation-speed: 0.3s;
      }

      body {
        font-family: sans-serif;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        background-color: #f0f0f0;
        margin: 0;
        padding: 20px;
        box-sizing: border-box;
        background: linear-gradient(
          135deg,
          #6e8efb,
          #a777e3
        ); /* Calming gradient */
      }

      .game-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px;
        background-color: rgba(255, 255, 255, 0.1);
        border-radius: 15px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        max-width: 95%;
      }

      .game-info {
        display: flex;
        justify-content: space-between; /* Space out elements */
        width: 100%;
        max-width: 600px; /* Limit width of info bar */
        margin-bottom: 20px;
        color: white;
        font-size: 1.2em;
        font-weight: bold;
        padding: 0 10px;
        flex-wrap: wrap; /* Allow wrapping if space is tight */
        gap: 10px; /* Add gap between info items */
      }

      /* Style for individual info items */
      .info-item {
        flex: 1; /* Allow items to grow */
        min-width: 100px; /* Minimum width before wrapping */
        text-align: center; /* Center text within item */
      }
      /* Ensure target moves takes adequate space */
      #targetMoves {
        flex-grow: 1.5; /* Give slightly more space */
      }

      .tubes-container {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 20px;
        margin-bottom: 20px;
        padding: 10px;
        max-width: 100%;
      }

      .tube {
        width: var(--tube-width);
        height: var(--tube-height);
        border: 3px solid #ccc;
        border-bottom-left-radius: var(--tube-bottom-radius);
        border-bottom-right-radius: var(--tube-bottom-radius);
        border-top-left-radius: var(--tube-border-radius);
        border-top-right-radius: var(--tube-border-radius);
        background-color: rgba(255, 255, 255, 0.3);
        position: relative;
        overflow: hidden;
        cursor: pointer;
        transition: transform var(--animation-speed) ease,
          box-shadow var(--animation-speed) ease;
        display: flex;
        flex-direction: column-reverse; /* Stack liquids from bottom */
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      }

      .tube.selected {
        transform: translateY(-15px) scale(1.05);
        border-color: #ffeb3b; /* Yellow highlight */
        box-shadow: 0 6px 15px rgba(255, 235, 59, 0.5);
      }

      .liquid {
        width: 100%;
        height: var(--liquid-height);
        transition: background-color var(--animation-speed) ease,
          height var(--animation-speed) ease;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 0.7em; /* Just for debugging color names if needed */
        color: white;
        text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
      }

      .controls {
        display: flex;
        gap: 15px;
        margin-top: 10px;
        align-items: center; /* Align items vertically */
        flex-wrap: wrap; /* Allow buttons to wrap */
        justify-content: center; /* Center buttons when wrapped */
      }

      button {
        padding: 10px 20px;
        font-size: 1em;
        cursor: pointer;
        border: none;
        border-radius: 8px;
        background-color: #8e44ad;
        color: white;
        transition: background-color 0.2s ease, transform 0.1s ease;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        margin-bottom: 5px; /* Add space below buttons if they wrap */
      }

      button:hover {
        background-color: #9b59b6;
      }
      button:active {
        transform: scale(0.95);
      }
      button:disabled {
        background-color: #bdc3c7;
        cursor: not-allowed;
      }

      .win-message {
        position: fixed; /* Use fixed to overlay */
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(0, 180, 0, 0.9);
        color: white;
        padding: 30px 50px;
        border-radius: 15px;
        font-size: 2em;
        font-weight: bold;
        text-align: center;
        z-index: 1000;
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        animation: fadeIn 0.5s ease-out;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translate(-50%, -60%);
        }
        to {
          opacity: 1;
          transform: translate(-50%, -50%);
        }
      }

      /* Basic responsiveness */
      @media (max-width: 600px) {
        :root {
          --tube-width: 50px;
          --tube-height: 200px;
          --liquid-height: 50px;
        }
        .game-info {
          font-size: 1em;
          justify-content: center; /* Center info items on smaller screens */
        }
        .info-item {
          min-width: 80px; /* Adjust min-width */
        }
        .win-message {
          font-size: 1.5em;
          padding: 20px 30px;
        }
      }
      @media (max-width: 400px) {
        :root {
          --tube-width: 45px;
          --tube-height: 180px;
          --liquid-height: 45px;
        }
        .tubes-container {
          gap: 15px;
        }
        .game-info {
          font-size: 0.9em;
        }
      }
    </style>
  </head>
  <body>
    <div class="game-container">
      <div class="game-info">
        <!-- Updated Info Area -->
        <span class="info-item" id="targetMoves">Difficulty: Medium</span>
        <span class="info-item" id="moves">Moves: 0</span>
      </div>
      <div class="tubes-container" id="tubesContainer">
        <!-- Tubes will be generated here by JavaScript -->
      </div>
      <div class="controls">
        <!-- Removed Level Selector -->
        <button id="undoBtn">Undo</button>
        <button id="restartBtn">Restart</button>
        <!-- Added New Game Button -->
        <button id="newGameBtn">New Game</button>
      </div>
      <div id="winMessage" class="win-message" style="display: none">
        Solved! ðŸŽ‰
      </div>
    </div>

    <script>
      const tubesContainer = document.getElementById("tubesContainer");
      const movesSpan = document.getElementById("moves");
      const targetMovesSpan = document.getElementById("targetMoves"); // New element reference
      const undoBtn = document.getElementById("undoBtn");
      const restartBtn = document.getElementById("restartBtn");
      const newGameBtn = document.getElementById("newGameBtn"); // New element reference
      const winMessageDiv = document.getElementById("winMessage");

      const TUBE_CAPACITY = 4;
      const COLORS = {
        red: "#e74c3c",
        blue: "#3498db",
        green: "#2ecc71",
        yellow: "#f1c40f",
        purple: "#9b59b6",
        orange: "#e67e22",
        pink: "#fd79a8",
        cyan: "#00cec9",
        lime: "#a2e041",
        brown: "#8b4513",
        gray: "#808080",
        teal: "#008080",
      };
      const COLOR_NAMES = Object.keys(COLORS);
      const NUM_EMPTY_TUBES = 2; // Typically 2 empty tubes

      // --- Difficulty Settings ---
      const DIFFICULTY_SETTINGS = {
        easy: { colors: 4 },
        medium: { colors: 6 },
        hard: { colors: 8 },
        expert: { colors: 10 },
      };
      let currentDifficulty = "medium"; // Default difficulty

      let tubes = []; // Array of arrays, representing tubes and their colors bottom-to-top
      let currentGameInitialState = []; // To store the state for the restart button
      let targetMoves = 0; // Target moves concept removed from generator
      let selectedTubeIndex = -1;
      let moves = 0;
      let history = []; // To store game states for undo
      let gameWon = false;

      // --- Core Game Logic ---

      function getRandomInt(min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min) + min); // The maximum is exclusive and the minimum is inclusive
      }

      /**
       * Generates a random initial state where:
       * 1. Tubes are either completely full or completely empty.
       * 2. Full tubes are placed to the left, empty to the right.
       * 3. No color appears 3 times consecutively in any tube.
       * @param {number} numColors - Number of distinct colors to use.
       * @param {number} numEmpty - Number of empty tubes.
       * @returns {{initialState: Array<Array<string>>, targetMoves: number}}
       */
      function generateRandomInitialState(numColors, numEmpty) {
        if (numColors > COLOR_NAMES.length) {
          console.warn(
            `Requested ${numColors} colors, but only ${COLOR_NAMES.length} are defined. Using ${COLOR_NAMES.length}.`
          );
          numColors = COLOR_NAMES.length;
        }
        const totalTubes = numColors + numEmpty;
        const availableColors = COLOR_NAMES.slice(0, numColors);

        // 1. Create the pool of all liquid blocks
        let blockPool = [];
        for (const color of availableColors) {
          for (let i = 0; i < TUBE_CAPACITY; i++) {
            blockPool.push(color);
          }
        }

        // 2. Shuffle the pool - Fisher-Yates (Knuth) Shuffle
        for (let i = blockPool.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [blockPool[i], blockPool[j]] = [blockPool[j], blockPool[i]];
        }

        // 3. Distribute blocks into full tubes with constraints
        let initialState = Array.from({ length: numColors }, () => []);
        let currentPoolIndex = 0; // Index for iterating through the shuffled pool

        // Helper to check the 3-consecutive constraint
        function checkConsecutiveConstraint(tube, newColor) {
          const len = tube.length;
          if (len < 2) return true; // Cannot violate with 0 or 1 existing blocks
          // Check if the top two existing blocks are the same as the new color
          return !(tube[len - 1] === newColor && tube[len - 2] === newColor);
        }

        for (let tubeIdx = 0; tubeIdx < numColors; tubeIdx++) {
          while (initialState[tubeIdx].length < TUBE_CAPACITY) {
             // Error check: ensure we still have blocks
            if (currentPoolIndex >= blockPool.length) {
              console.error(
                "Error: Not enough blocks in pool to fill tubes. Pool exhausted."
              );
               // Pad remaining tubes (full and empty) and return error state
               while(initialState[tubeIdx].length < TUBE_CAPACITY) initialState[tubeIdx].push('gray'); // Pad with default color
               for (let i = tubeIdx + 1; i < numColors; i++) { initialState.push(Array(TUBE_CAPACITY).fill('gray')); }
               for (let i = 0; i < numEmpty; i++) { initialState.push([]); }
               return { initialState: initialState, targetMoves: 0 }; // Return potentially broken state
            }

            let placed = false;
            let checkIndex = currentPoolIndex; // Start checking from the current block

            // Find the next available block that satisfies the constraint
            while (checkIndex < blockPool.length) {
              const potentialBlock = blockPool[checkIndex];
              if (
                checkConsecutiveConstraint(initialState[tubeIdx], potentialBlock)
              ) {
                // Found a valid block!
                // Swap it to the currentPoolIndex position if it's not already there
                if (checkIndex !== currentPoolIndex) {
                  [blockPool[currentPoolIndex], blockPool[checkIndex]] = [
                    blockPool[checkIndex],
                    blockPool[currentPoolIndex],
                  ];
                }
                // Place the block from currentPoolIndex
                initialState[tubeIdx].push(blockPool[currentPoolIndex]);
                currentPoolIndex++; // Move to the next block in the pool for the *next* placement attempt
                placed = true;
                break; // Exit the inner while loop (search loop) and move to next slot
              }
              checkIndex++; // Check the next block in the pool
            } // End of constraint checking loop

            if (!placed) {
              // Fallback: No block from currentPoolIndex onwards satisfies the constraint for this tube/slot.
              // This implies all remaining blocks would violate the 3-in-a-row rule here.
              // Place the block at currentPoolIndex anyway and log a warning.
              const fallbackBlock = blockPool[currentPoolIndex];
              console.warn(
                `Constraint unavoidable at tube ${tubeIdx}, position ${initialState[tubeIdx].length}. Placing block ${fallbackBlock}. Consider using fewer colors or larger capacity.`
              );
              initialState[tubeIdx].push(fallbackBlock);
              currentPoolIndex++; // Consume the block from the pool
            }
            // Continue the outer while loop (initialState[tubeIdx].length < TUBE_CAPACITY)
          } // End of while loop for filling one tube
        } // End of for loop iterating through tubes

        // 4. Add empty tubes (Requirement 1 & 2)
        for (let i = 0; i < numEmpty; i++) {
          initialState.push([]);
        }

        // 5. Sorting (Full Left, Empty Right) is implicit due to order of creation/addition.

        // Final check (debugging)
        if (currentPoolIndex !== blockPool.length) {
          console.warn(
            `Generation finished, but ${
              blockPool.length - currentPoolIndex
            } blocks remain unused in the pool. Pool size: ${
              blockPool.length
            }, Used: ${currentPoolIndex}`
          );
        } else {
             console.log("Generated initial state successfully. All blocks placed.");
        }

        // 6. Return state. Target moves are not calculated by this method.
        return { initialState: initialState, targetMoves: 0 }; // targetMoves is 0
      }

      // (Removed isSolved function as it's not used by the new generator)

      function initGame(difficulty = currentDifficulty) {
        console.log(`Initializing Game - Difficulty: ${difficulty}`);
        currentDifficulty = difficulty; // Update current difficulty
        const settings =
          DIFFICULTY_SETTINGS[difficulty] || DIFFICULTY_SETTINGS.medium;

        // Generate the random state using the new method
        const { initialState, targetMoves: generatedTargetMoves } = // generatedTargetMoves will be 0
          generateRandomInitialState(settings.colors, NUM_EMPTY_TUBES);

        // Store the initial state for Restart
        currentGameInitialState = JSON.parse(JSON.stringify(initialState));
        targetMoves = generatedTargetMoves; // Store target moves (will be 0)

        // Set the active game state
        tubes = JSON.parse(JSON.stringify(initialState));

        selectedTubeIndex = -1;
        moves = 0;
        history = []; // Clear history
        gameWon = false;
        winMessageDiv.style.display = "none"; // Hide win message

        updateMovesDisplay(); // Update moves count (0)
        updateTargetMovesDisplay(); // Update target/difficulty display

        saveState(); // Save the initial state for undo
        renderTubes();
        updateUndoButton();
      }

      function restartGame() {
        console.log("Restarting current game.");
        if (currentGameInitialState.length === 0) {
          console.error("No initial state saved. Cannot restart.");
          initGame(); // Generate a new game if restart fails
          return;
        }
        // Restore the active state from the saved initial state
        tubes = JSON.parse(JSON.stringify(currentGameInitialState));

        // Reset game variables
        selectedTubeIndex = -1;
        moves = 0;
        history = []; // Clear history
        gameWon = false;
        winMessageDiv.style.display = "none";

        updateMovesDisplay(); // Reset moves display
        updateTargetMovesDisplay(); // Update target/difficulty display (stays same)
        saveState(); // Save the restarted initial state for undo
        renderTubes();
        updateUndoButton();
      }

      function renderTubes() {
        tubesContainer.innerHTML = ""; // Clear previous tubes
        tubes.forEach((tubeData, index) => {
          const tubeElement = document.createElement("div");
          tubeElement.classList.add("tube");
          tubeElement.dataset.index = index; // Store index for click handling

          // Add liquids from bottom up
          tubeData.forEach((color) => {
            const liquidSegment = document.createElement("div");
            liquidSegment.classList.add("liquid");
            liquidSegment.style.backgroundColor = COLORS[color] || "#cccccc"; // Default color if not found
            tubeElement.appendChild(liquidSegment);
          });

          // Fill remaining space visually - handled by flex-direction: column-reverse and liquid height
          const emptySpaces = TUBE_CAPACITY - tubeData.length;
           if (emptySpaces > 0 && emptySpaces < TUBE_CAPACITY) {
               // This case should ideally not happen with the new generator (only full or empty)
               // But good for robustness during gameplay
                for (let i = 0; i < emptySpaces; i++) {
                    const emptySegment = document.createElement("div");
                    emptySegment.classList.add("liquid");
                    emptySegment.style.height = `var(--liquid-height)`;
                    emptySegment.style.backgroundColor = "transparent";
                    tubeElement.appendChild(emptySegment);
                }
           }


          if (index === selectedTubeIndex) {
            tubeElement.classList.add("selected");
          }

          tubeElement.addEventListener("click", handleTubeClick);
          tubesContainer.appendChild(tubeElement);
        });
      }

      function handleTubeClick(event) {
        if (gameWon) return; // Don't allow moves after winning

        const clickedIndex = parseInt(event.currentTarget.dataset.index);

        if (selectedTubeIndex === -1) {
          // First click: Select source tube
          if (tubes[clickedIndex].length > 0) {
            // Can only select non-empty tubes
            selectedTubeIndex = clickedIndex;
            renderTubes(); // Re-render to show selection
          }
        } else {
          // Second click: Select destination tube or deselect
          if (clickedIndex === selectedTubeIndex) {
            // Clicked the same tube again: Deselect
            selectedTubeIndex = -1;
            renderTubes();
          } else {
            // Attempt to pour
            if (canPour(selectedTubeIndex, clickedIndex)) {
              saveState(); // Save state *before* making the move
              doPour(selectedTubeIndex, clickedIndex);
              moves++;
              updateMovesDisplay();
              selectedTubeIndex = -1; // Deselect after pour
              renderTubes();
              updateUndoButton(); // Update undo button state after move
              checkWinCondition();
            } else {
              // Invalid move - maybe add visual feedback later (e.g., shake)
              console.log("Invalid move");
              selectedTubeIndex = -1; // Deselect if move is invalid
              renderTubes(); // Re-render to remove selection highlight
            }
          }
        }
      }

      function getTopColor(tube) {
        return tube.length > 0 ? tube[tube.length - 1] : null;
      }

      function canPour(sourceIndex, destIndex) {
        const sourceTube = tubes[sourceIndex];
        const destTube = tubes[destIndex];

        if (sourceTube.length === 0) return false; // Cannot pour from empty tube
        if (destTube.length >= TUBE_CAPACITY) return false; // Cannot pour into full tube

        const topColorSource = getTopColor(sourceTube);
        const topColorDest = getTopColor(destTube);

        // Can pour if destination is empty OR top colors match
        return topColorDest === null || topColorSource === topColorDest;
      }

      function doPour(sourceIndex, destIndex) {
        const sourceTube = tubes[sourceIndex];
        const destTube = tubes[destIndex];
        const colorToMove = getTopColor(sourceTube);

        if (!colorToMove) return; // Should not happen if canPour is checked, but good practice

        // Find how many blocks of the same color are at the top of the source tube
        let pourAmount = 0;
        for (let i = sourceTube.length - 1; i >= 0; i--) {
          if (sourceTube[i] === colorToMove) {
            pourAmount++;
          } else {
            break; // Stop if a different color is encountered
          }
        }

        // Limit pour amount by available space in destination tube
        const availableSpace = TUBE_CAPACITY - destTube.length;
        pourAmount = Math.min(pourAmount, availableSpace);

        // Perform the transfer
        for (let i = 0; i < pourAmount; i++) {
           // Check if source tube is empty before popping (safety)
           if (sourceTube.length === 0) {
               console.error("Attempted to pop from empty source tube during pour loop.");
               break;
           }
          destTube.push(sourceTube.pop());
        }
      }

      function checkWinCondition() {
        if (gameWon) return; // Already won

        for (const tube of tubes) {
          if (tube.length > 0 && tube.length < TUBE_CAPACITY) {
            return; // Partially filled tube exists
          }
          if (tube.length === TUBE_CAPACITY) {
            const firstColor = tube[0];
            for (let i = 1; i < tube.length; i++) {
              if (tube[i] !== firstColor) {
                return; // Found a different color in a full tube
              }
            }
          }
          // Empty tubes (tube.length === 0) are fine
        }

        // If we reach here, all non-empty tubes are full of a single color
        console.log("Win condition met!");
        gameWon = true;
        winMessageDiv.textContent = `Solved in ${moves} moves!`; // Show moves count
        winMessageDiv.style.display = "block";
        updateUndoButton(); // Disable undo after winning

        // Optional: Automatically start a new game after a delay
        // setTimeout(() => {
        //   winMessageDiv.style.display = "none";
        // }, 3000);
      }

      function updateMovesDisplay() {
        movesSpan.textContent = `Moves: ${moves}`;
      }

      // --- Updated function to display difficulty instead of target moves ---
      function updateTargetMovesDisplay() {
        // Capitalize first letter of difficulty
        const difficultyDisplay = currentDifficulty.charAt(0).toUpperCase() + currentDifficulty.slice(1);
        targetMovesSpan.textContent = `Difficulty: ${difficultyDisplay}`;
      }

      // --- Undo Functionality ---

      function saveState() {
        // Save a deep copy of the current state
        history.push(
          JSON.parse(JSON.stringify({ tubes: tubes, moves: moves }))
        );
         // Limit history size to prevent memory issues (e.g., keep last 50 states)
         const MAX_HISTORY = 50;
         if (history.length > MAX_HISTORY) {
             history.shift(); // Remove the oldest state
         }
      }

      function undoMove() {
        if (gameWon) return; // Cannot undo after winning
        if (history.length > 1) {
          // Need at least the initial state + one move to undo
          history.pop(); // Remove the current state
          const previousState = history[history.length - 1]; // Get the state before the last move

          // Restore the previous state (deep copy)
          tubes = JSON.parse(JSON.stringify(previousState.tubes));
          moves = previousState.moves;

          selectedTubeIndex = -1; // Reset selection
          renderTubes();
          updateMovesDisplay();
          updateUndoButton();
          winMessageDiv.style.display = "none"; // Hide win message if it was shown erroneously
          gameWon = false; // Ensure game isn't marked as won
        } else {
          console.log("Cannot undo further.");
        }
      }

      function updateUndoButton() {
        undoBtn.disabled = history.length <= 1 || gameWon; // Disable if only initial state left or game won
      }

      // --- Event Listeners ---
      restartBtn.addEventListener("click", restartGame); // Use the new restart function
      undoBtn.addEventListener("click", undoMove);
      // Update New Game button to allow selecting difficulty (optional, for now just restarts with current)
      // For simplicity, New Game just uses the current difficulty setting.
      newGameBtn.addEventListener("click", () => initGame(currentDifficulty));

      // --- Initial Game Load ---
      window.onload = () => {
        initGame(); // Initialize the game with default difficulty
      };
    </script>
  </body>
</html>