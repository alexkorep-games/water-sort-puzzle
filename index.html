<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- PWA Meta Tags -->
    <link rel="manifest" href="manifest.json" />
    <meta name="theme-color" content="#8e44ad" />
    <link rel="apple-touch-icon" href="icons/icon-192x192.png" />
    <!-- End PWA Meta Tags -->

    <title>Color Liquid Sort Puzzle - Shuffled (Solvability Check v3)</title>
    <style>
      :root {
        --tube-width: 60px;
        --tube-height: 240px;
        --liquid-height: 60px; /* --tube-height / capacity */
        --tube-border-radius: 10px;
        --tube-bottom-radius: 30px;
        --animation-speed: 0.3s;
      }

      body {
        font-family: sans-serif;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        background-color: #f0f0f0;
        margin: 0;
        padding: 20px;
        box-sizing: border-box;
        background: linear-gradient(
          135deg,
          #6e8efb,
          #a777e3
        ); /* Calming gradient */
      }

      .game-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px;
        background-color: rgba(255, 255, 255, 0.1);
        border-radius: 15px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        max-width: 95%;
      }

      #solvabilityMessage {
        display: none; /* Hidden by default */
        color: #ffdddd; /* Light red/pink for visibility */
        background-color: rgba(
          231,
          76,
          60,
          0.7
        ); /* Semi-transparent red background */
        padding: 8px 15px;
        border-radius: 5px;
        margin-bottom: 15px; /* Space below the message */
        font-weight: bold;
        text-align: center;
        width: 100%;
        max-width: 600px; /* Match game info width */
        box-sizing: border-box;
      }

      .game-info {
        display: flex;
        justify-content: space-between; /* Space out elements */
        width: 100%;
        max-width: 600px; /* Limit width of info bar */
        margin-bottom: 20px;
        color: white;
        font-size: 1.2em;
        font-weight: bold;
        padding: 0 10px;
        flex-wrap: wrap; /* Allow wrapping if space is tight */
        gap: 10px; /* Add gap between info items */
      }

      .info-item {
        flex: 1; /* Allow items to grow */
        min-width: 100px; /* Minimum width before wrapping */
        text-align: center; /* Center text within item */
      }
      #targetMoves {
        flex-grow: 1.5; /* Give slightly more space */
      }

      .tubes-container {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 20px;
        margin-bottom: 20px;
        padding: 10px;
        max-width: 100%;
      }

      .tube {
        width: var(--tube-width);
        height: var(--tube-height);
        border: 3px solid #ccc;
        border-bottom-left-radius: var(--tube-bottom-radius);
        border-bottom-right-radius: var(--tube-bottom-radius);
        border-top-left-radius: var(--tube-border-radius);
        border-top-right-radius: var(--tube-border-radius);
        background-color: rgba(255, 255, 255, 0.3);
        position: relative;
        overflow: hidden;
        cursor: pointer;
        transition: transform var(--animation-speed) ease,
          box-shadow var(--animation-speed) ease;
        display: flex;
        flex-direction: column-reverse; /* Stack liquids from bottom */
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      }

      .tube.selected {
        transform: translateY(-15px) scale(1.05);
        border-color: #ffeb3b; /* Yellow highlight */
        box-shadow: 0 6px 15px rgba(255, 235, 59, 0.5);
      }

      .liquid {
        width: 100%;
        height: var(--liquid-height);
        transition: background-color var(--animation-speed) ease,
          height var(--animation-speed) ease;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 0.7em; /* Just for debugging color names if needed */
        color: white;
        text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
      }

      .controls {
        display: flex;
        gap: 15px;
        margin-top: 10px;
        align-items: center; /* Align items vertically */
        flex-wrap: wrap; /* Allow buttons to wrap */
        justify-content: center; /* Center buttons when wrapped */
      }

      button,
      select#difficultySelect {
        padding: 10px 20px;
        font-size: 1em;
        cursor: pointer;
        border: none;
        border-radius: 8px;
        background-color: #8e44ad;
        color: white;
        transition: background-color 0.2s ease, transform 0.1s ease;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        margin-bottom: 5px; /* Add space below buttons if they wrap */
        font-family: sans-serif; /* Ensure font consistency */
      }

      button:hover,
      select#difficultySelect:hover {
        background-color: #9b59b6;
      }
      button:active {
        transform: scale(0.95);
      }
      button:disabled {
        background-color: #bdc3c7;
        cursor: not-allowed;
      }

      .controls label {
        color: white;
        font-weight: bold;
        margin-right: -5px; /* Adjust spacing slightly */
        margin-bottom: 5px; /* Align with button margin */
      }

      select#difficultySelect {
        padding: 10px 15px; /* Adjust padding slightly for select appearance */
      }

      .win-message {
        position: fixed; /* Use fixed to overlay */
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(0, 180, 0, 0.9);
        color: white;
        padding: 30px 50px;
        border-radius: 15px;
        font-size: 2em;
        font-weight: bold;
        text-align: center;
        z-index: 1000;
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        animation: fadeIn 0.5s ease-out;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translate(-50%, -60%);
        }
        to {
          opacity: 1;
          transform: translate(-50%, -50%);
        }
      }

      /* Basic responsiveness */
      @media (max-width: 700px) {
        .controls {
          flex-direction: column;
          align-items: stretch;
          gap: 10px;
        }
        .controls label {
          text-align: center;
          margin-right: 0;
        }
        button,
        select#difficultySelect {
          width: 100%;
          max-width: 250px;
          margin: 0 auto 10px auto;
        }
      }
      @media (max-width: 600px) {
        :root {
          --tube-width: 50px;
          --tube-height: 200px;
          --liquid-height: 50px;
        }
        .game-info {
          font-size: 1em;
          justify-content: center;
        }
        .info-item {
          min-width: 80px;
        }
        .win-message {
          font-size: 1.5em;
          padding: 20px 30px;
        }
      }
      @media (max-width: 400px) {
        :root {
          --tube-width: 45px;
          --tube-height: 180px;
          --liquid-height: 45px;
        }
        .tubes-container {
          gap: 15px;
        }
        .game-info {
          font-size: 0.9em;
        }
      }
    </style>
  </head>
  <body>
    <div class="game-container">
      <div id="solvabilityMessage">
        <!-- Message set by JS -->
      </div>

      <div class="game-info">
        <span class="info-item" id="targetMoves">Difficulty: Medium</span>
        <span class="info-item" id="moves">Moves: 0</span>
      </div>
      <div class="tubes-container" id="tubesContainer">
        <!-- Tubes will be generated here by JavaScript -->
      </div>
      <div class="controls">
        <label for="difficultySelect">Difficulty:</label>
        <select id="difficultySelect">
          <option value="easy">Easy</option>
          <option value="medium" selected>Medium</option>
          <option value="hard">Hard</option>
          <option value="expert">Expert</option>
        </select>
        <button id="undoBtn">Undo</button>
        <button id="restartBtn">Restart</button>
        <button id="newGameBtn">New Game</button>
      </div>
      <div id="winMessage" class="win-message" style="display: none">
        Solved! ðŸŽ‰
      </div>
    </div>

    <script>
      const tubesContainer = document.getElementById("tubesContainer");
      const movesSpan = document.getElementById("moves");
      const targetMovesSpan = document.getElementById("targetMoves");
      const undoBtn = document.getElementById("undoBtn");
      const restartBtn = document.getElementById("restartBtn");
      const newGameBtn = document.getElementById("newGameBtn");
      const winMessageDiv = document.getElementById("winMessage");
      const difficultySelect = document.getElementById("difficultySelect");
      const solvabilityMessageDiv =
        document.getElementById("solvabilityMessage");

      // --- Global Game Constants ---
      const TUBE_CAPACITY = 4; // Make sure this is consistent
      const COLORS = {
        red: "#e74c3c",
        blue: "#3498db",
        green: "#2ecc71",
        yellow: "#f1c40f",
        purple: "#9b59b6",
        orange: "#e67e22",
        pink: "#fd79a8",
        cyan: "#00cec9",
        lime: "#a2e041",
        brown: "#8b4513",
        gray: "#808080",
        teal: "#008080",
      };
      const COLOR_NAMES = Object.keys(COLORS);
      const NUM_EMPTY_TUBES = 2;

      // --- Difficulty Settings ---
      const DIFFICULTY_SETTINGS = {
        easy: { colors: 4 },
        medium: { colors: 6 },
        hard: { colors: 8 },
        expert: { colors: 10 },
      };
      let currentDifficulty = "medium";

      // --- Global Game State Variables ---
      let tubes = [];
      let currentGameInitialState = [];
      let selectedTubeIndex = -1;
      let moves = 0;
      let history = [];
      let gameWon = false;
      let testMode = false; // Flag to control test execution and BFS limits

      // --- Core Game Logic ---

      function getRandomInt(min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min) + min);
      }

      function generateRandomInitialState(numColors, numEmpty) {
        // (Code unchanged from previous version)
        if (numColors > COLOR_NAMES.length) {
          console.warn(
            `Requested ${numColors} colors, only ${COLOR_NAMES.length} available. Using ${COLOR_NAMES.length}.`
          );
          numColors = COLOR_NAMES.length;
        }
        const totalTubes = numColors + numEmpty;
        const availableColors = COLOR_NAMES.slice(0, numColors);
        let blockPool = [];
        availableColors.forEach((color) => {
          for (let i = 0; i < TUBE_CAPACITY; i++) blockPool.push(color);
        });

        for (let i = blockPool.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [blockPool[i], blockPool[j]] = [blockPool[j], blockPool[i]];
        }

        let initialState = Array.from({ length: totalTubes }, () => []);
        let currentPoolIndex = 0;
        for (let tubeIdx = 0; tubeIdx < numColors; tubeIdx++) {
          for (let j = 0; j < TUBE_CAPACITY; j++) {
            if (currentPoolIndex < blockPool.length) {
              initialState[tubeIdx].push(blockPool[currentPoolIndex++]);
            } else {
              console.error("Block pool exhausted during generation!");
              break;
            }
          }
          if (currentPoolIndex >= blockPool.length && tubeIdx < numColors - 1) {
            console.error("Block pool exhausted prematurely!");
            break;
          }
        }
        if (currentPoolIndex !== blockPool.length) {
          console.warn(
            `Pool Mismatch: Pool size ${blockPool.length}, Used ${currentPoolIndex}`
          );
        }
        return { initialState: initialState, targetMoves: 0 };
      }

      // --- Basic Solvability Check (Color Counts) ---
      function checkBasicSolvability() {
        const colorCounts = {};
        let totalBlocks = 0;
        const activeColors = COLOR_NAMES.slice(
          0,
          DIFFICULTY_SETTINGS[currentDifficulty]?.colors ?? 0
        );

        if (activeColors.length === 0 && tubes.flat().length > 0) {
          return {
            solvable: false,
            message: "Invalid difficulty setting for color count.",
          };
        }

        let blockCountsByColor = {}; // Track counts for checking TUBE_CAPACITY

        for (const tube of tubes) {
          for (const color of tube) {
            blockCountsByColor[color] = (blockCountsByColor[color] || 0) + 1;
            totalBlocks++;
            // Check if color is unexpected *immediately*
            if (!activeColors.includes(color)) {
              // This error logging can be noisy during tests designed to fail here.
              if (!testMode)
                console.error(
                  `Basic Check Fail: Unexpected color '${color}' found for difficulty '${currentDifficulty}'.`
                );
              return {
                solvable: false,
                message: `Generation error: Unexpected color '${color}'.`,
              };
            }
          }
        }

        const expectedTotalBlocks = activeColors.length * TUBE_CAPACITY;
        if (totalBlocks !== expectedTotalBlocks) {
          // Logged only if it's not a test designed to fail this way
          if (!testMode)
            console.error(
              `Basic Check Fail: Total blocks mismatch. Found ${totalBlocks}, expected ${expectedTotalBlocks} for ${activeColors.length} colors.`
            );
          return {
            solvable: false,
            message: `Generation error: Incorrect total blocks (${totalBlocks} vs ${expectedTotalBlocks}).`,
          };
        }

        // Now check if each *active* color has the right count
        for (const color of activeColors) {
          if ((blockCountsByColor[color] || 0) !== TUBE_CAPACITY) {
            const count = blockCountsByColor[color] || 0;
            // Logged only if it's not a test designed to fail this way
            if (!testMode)
              console.error(
                `Basic Check Fail: Color '${color}' count is ${count}, expected ${TUBE_CAPACITY}`
              );
            return {
              solvable: false,
              message: `Generation error: Color '${color}' has ${count}, expected ${TUBE_CAPACITY}.`,
            };
          }
        }
        return { solvable: true, message: "" };
      }

      // --- Helper functions for State Manipulation (Used by BFS) ---
      function getTopColorForState(tube) {
        return tube.length > 0 ? tube[tube.length - 1] : null;
      }

      function canPourState(sourceTube, destTube) {
        // (Code unchanged)
        if (sourceTube.length === 0) return false;
        if (destTube.length >= TUBE_CAPACITY) return false;
        const topColorSource = getTopColorForState(sourceTube);
        const topColorDest = getTopColorForState(destTube);
        return topColorDest === null || topColorSource === topColorDest;
      }

      function createNextState(currentState, sourceIndex, destIndex) {
        // (Code unchanged)
        const nextState = JSON.parse(JSON.stringify(currentState));
        const sourceTube = nextState[sourceIndex];
        const destTube = nextState[destIndex];
        const colorToMove = getTopColorForState(sourceTube);
        if (!colorToMove) return null;

        let pourAmount = 0;
        for (let i = sourceTube.length - 1; i >= 0; i--) {
          if (sourceTube[i] === colorToMove) pourAmount++;
          else break;
        }
        const availableSpace = TUBE_CAPACITY - destTube.length;
        pourAmount = Math.min(pourAmount, availableSpace);

        for (let i = 0; i < pourAmount; i++) {
          if (sourceTube.length === 0) break;
          destTube.push(sourceTube.pop());
        }
        return nextState;
      }

      function checkWinConditionForState(tubesState) {
        // (Code unchanged)
        for (const tube of tubesState) {
          if (tube.length === 0) continue;
          if (tube.length < TUBE_CAPACITY) return false;
          const firstColor = tube[0];
          for (let i = 1; i < tube.length; i++) {
            if (tube[i] !== firstColor) return false;
          }
        }
        return true;
      }

      function stringifyState(tubesState) {
        return JSON.stringify(tubesState);
      }

      // --- BFS Solvability Check Algorithm ---
      function isSolvableBFS(initialTubesState) {
        // (Code unchanged - Max iterations already increased)
        console.log("Starting BFS Solvability Check...");
        const startTime = performance.now();
        const queue = [initialTubesState];
        const visited = new Set();
        visited.add(stringifyState(initialTubesState));
        let iterations = 0;
        const MAX_ITERATIONS = testMode ? 10000 : 200000;
        const numTubes = initialTubesState.length;

        while (queue.length > 0) {
          iterations++;
          if (iterations > MAX_ITERATIONS) {
            console.warn(
              `BFS Solvability Check aborted after ${MAX_ITERATIONS} iterations.`
            );
            return false;
          }
          if (iterations % 25000 === 0 && !testMode) {
            console.log(
              `BFS: Iteration ${iterations}, Queue: ${queue.length}, Visited: ${visited.size}`
            );
          }

          const currentState = queue.shift();
          if (checkWinConditionForState(currentState)) {
            const endTime = performance.now();
            console.log(
              `BFS Solvability Check: Solvable! Found in ${iterations} iterations (${(
                endTime - startTime
              ).toFixed(2)} ms). Visited: ${visited.size}`
            );
            return true;
          }

          for (let i = 0; i < numTubes; i++) {
            if (currentState[i].length === 0) continue;
            for (let j = 0; j < numTubes; j++) {
              if (i === j) continue;
              if (canPourState(currentState[i], currentState[j])) {
                const nextState = createNextState(currentState, i, j);
                if (nextState) {
                  const nextStateString = stringifyState(nextState);
                  if (!visited.has(nextStateString)) {
                    visited.add(nextStateString);
                    queue.push(nextState);
                  }
                }
              }
            }
          }
        }
        const endTime = performance.now();
        console.log(
          `BFS Solvability Check: Unsolvable. Explored ${iterations} iterations (${(
            endTime - startTime
          ).toFixed(2)} ms). Visited: ${visited.size}`
        );
        return false;
      }

      // --- Game Initialization and Control ---
      function initGame(difficulty, skipBFS = false) {
        // (Code unchanged - context handling already improved)
        console.log(
          `Initializing Game - Difficulty: ${difficulty}, Skip BFS: ${skipBFS}`
        );
        solvabilityMessageDiv.style.display = "none";
        solvabilityMessageDiv.textContent = "";
        winMessageDiv.style.display = "none";

        currentDifficulty = DIFFICULTY_SETTINGS[difficulty]
          ? difficulty
          : "medium";
        difficultySelect.value = currentDifficulty;
        const settings = DIFFICULTY_SETTINGS[currentDifficulty];
        if (!settings) {
          console.error(
            `Invalid difficulty setting: ${currentDifficulty}. Using medium.`
          );
          currentDifficulty = "medium";
          settings = DIFFICULTY_SETTINGS["medium"];
          difficultySelect.value = "medium";
        }

        let initialState;
        let isActuallySolvable = false;
        let generationAttempts = 0;
        const MAX_GENERATION_ATTEMPTS = skipBFS ? 1 : 5;

        do {
          generationAttempts++;
          if (!skipBFS)
            console.log(`Generation attempt ${generationAttempts}...`); // Only log attempt# if running BFS
          ({ initialState } = generateRandomInitialState(
            settings.colors,
            NUM_EMPTY_TUBES
          ));

          const originalTubes = tubes;
          const originalDifficulty = currentDifficulty;
          tubes = JSON.parse(JSON.stringify(initialState)); // Use copy for check
          currentDifficulty = difficulty;
          const basicCheckResult = checkBasicSolvability();
          tubes = originalTubes;
          currentDifficulty = originalDifficulty;

          if (!basicCheckResult.solvable) {
            console.warn(
              `Attempt ${generationAttempts}: Failed basic check: ${basicCheckResult.message}. Regenerating...`
            );
            continue;
          }

          if (skipBFS) {
            if (generationAttempts === 1)
              console.warn(
                "Skipping BFS solvability check as requested (faster init, rare risk of unsolvable)."
              );
            isActuallySolvable = true;
          } else {
            isActuallySolvable = isSolvableBFS(initialState);
            if (!isActuallySolvable) {
              console.warn(
                `Attempt ${generationAttempts}: Failed BFS check. Regenerating...`
              );
            }
          }
        } while (
          !isActuallySolvable &&
          generationAttempts < MAX_GENERATION_ATTEMPTS
        );

        if (
          !isActuallySolvable &&
          generationAttempts >= MAX_GENERATION_ATTEMPTS
        ) {
          console.error(
            `Failed to generate a solvable puzzle after ${MAX_GENERATION_ATTEMPTS} attempts for difficulty '${difficulty}'. Displaying error.`
          );
          solvabilityMessageDiv.textContent = `Error: Could not generate a solvable puzzle (${MAX_GENERATION_ATTEMPTS} attempts). Try 'New Game' or change difficulty.`;
          solvabilityMessageDiv.style.display = "block";
          tubes = Array.from(
            { length: settings.colors + NUM_EMPTY_TUBES },
            () => []
          );
          currentGameInitialState = JSON.parse(JSON.stringify(tubes));
          moves = 0;
          history = [];
          gameWon = false;
          selectedTubeIndex = -1;
          updateMovesDisplay();
          updateDifficultyDisplay();
          renderTubes();
          updateUndoButton();
          return;
        }

        if (!skipBFS || generationAttempts > 1) {
          // Only log success if BFS ran or needed retries
          console.log(
            `Successfully generated a ${
              skipBFS ? "potentially " : ""
            }solvable state on attempt ${generationAttempts}.`
          );
        }
        currentGameInitialState = JSON.parse(JSON.stringify(initialState));
        tubes = JSON.parse(JSON.stringify(initialState));
        currentDifficulty = difficulty;

        selectedTubeIndex = -1;
        moves = 0;
        history = [];
        gameWon = false;
        updateMovesDisplay();
        updateDifficultyDisplay();
        saveState();
        renderTubes();
        updateUndoButton();
      }

      function restartGame() {
        // (Code unchanged)
        console.log("Restarting game at difficulty:", currentDifficulty);
        solvabilityMessageDiv.style.display = "none";
        solvabilityMessageDiv.textContent = "";
        winMessageDiv.style.display = "none";

        if (!currentGameInitialState || currentGameInitialState.length === 0) {
          console.error("No initial state saved. Generating new game.");
          initGame(currentDifficulty, false);
          return;
        }

        tubes = JSON.parse(JSON.stringify(currentGameInitialState));

        const basicCheckResult = checkBasicSolvability();
        if (!basicCheckResult.solvable) {
          console.error(
            `Error on restart: Initial state failed basic solvability check (${basicCheckResult.message}).`
          );
          solvabilityMessageDiv.textContent = `Restart Error: ${basicCheckResult.message}. Try 'New Game'.`;
          solvabilityMessageDiv.style.display = "block";
        }

        selectedTubeIndex = -1;
        moves = 0;
        history = [];
        gameWon = false;
        updateMovesDisplay();
        updateDifficultyDisplay();
        saveState();
        renderTubes();
        updateUndoButton();
      }

      function renderTubes() {
        // (Code unchanged)
        tubesContainer.innerHTML = "";
        tubes.forEach((tubeData, index) => {
          const tubeElement = document.createElement("div");
          tubeElement.classList.add("tube");
          tubeElement.dataset.index = index;

          tubeData.forEach((color) => {
            const liquidSegment = document.createElement("div");
            liquidSegment.classList.add("liquid");
            liquidSegment.style.backgroundColor = COLORS[color] || "#cccccc";
            tubeElement.appendChild(liquidSegment);
          });

          if (index === selectedTubeIndex)
            tubeElement.classList.add("selected");
          tubeElement.addEventListener("click", handleTubeClick);
          tubesContainer.appendChild(tubeElement);
        });
      }

      function handleTubeClick(event) {
        // (Code unchanged)
        if (solvabilityMessageDiv.style.display === "block" || gameWon) return;
        const clickedIndex = parseInt(event.currentTarget.dataset.index);

        if (selectedTubeIndex === -1) {
          if (tubes[clickedIndex].length > 0) {
            selectedTubeIndex = clickedIndex;
            renderTubes();
          }
        } else {
          if (clickedIndex === selectedTubeIndex) {
            selectedTubeIndex = -1;
            renderTubes();
          } else {
            if (canPour(selectedTubeIndex, clickedIndex)) {
              saveState();
              doPour(selectedTubeIndex, clickedIndex);
              moves++;
              updateMovesDisplay();
              selectedTubeIndex = -1;
              renderTubes();
              updateUndoButton();
              checkWinCondition();
            } else {
              selectedTubeIndex = -1;
              renderTubes();
            }
          }
        }
      }

      // Gameplay state functions (operate on global `tubes`)
      function getTopColor(tube) {
        return tube.length > 0 ? tube[tube.length - 1] : null;
      }
      function canPour(sourceIndex, destIndex) {
        // (Code unchanged)
        const sourceTube = tubes[sourceIndex];
        const destTube = tubes[destIndex];
        if (!sourceTube || !destTube) return false;
        if (sourceTube.length === 0) return false;
        if (destTube.length >= TUBE_CAPACITY) return false;
        const topColorSource = getTopColor(sourceTube);
        const topColorDest = getTopColor(destTube);
        return topColorDest === null || topColorSource === topColorDest;
      }
      function doPour(sourceIndex, destIndex) {
        // (Code unchanged)
        const sourceTube = tubes[sourceIndex];
        const destTube = tubes[destIndex];
        if (!sourceTube || !destTube) return;

        const colorToMove = getTopColor(sourceTube);
        if (!colorToMove) return;
        let pourAmount = 0;
        for (let i = sourceTube.length - 1; i >= 0; i--) {
          if (sourceTube[i] === colorToMove) pourAmount++;
          else break;
        }
        const availableSpace = TUBE_CAPACITY - destTube.length;
        pourAmount = Math.min(pourAmount, availableSpace);
        for (let i = 0; i < pourAmount; i++) {
          if (sourceTube.length === 0) break;
          destTube.push(sourceTube.pop());
        }
      }

      function checkWinCondition() {
        // (Code unchanged)
        if (gameWon) return;
        if (checkWinConditionForState(tubes)) {
          console.log("Win condition met!");
          gameWon = true;
          winMessageDiv.textContent = `Solved in ${moves} moves! ðŸŽ‰`;
          winMessageDiv.style.display = "block";
          updateUndoButton();
        }
      }

      function updateMovesDisplay() {
        movesSpan.textContent = `Moves: ${moves}`;
      }
      function updateDifficultyDisplay() {
        const difficultyDisplay =
          currentDifficulty.charAt(0).toUpperCase() +
          currentDifficulty.slice(1);
        targetMovesSpan.textContent = `Difficulty: ${difficultyDisplay}`;
      }

      // --- Undo Functionality ---
      function saveState() {
        // (Code unchanged)
        if (tubes && tubes.length > 0 && tubes.some((t) => t.length > 0)) {
          history.push(
            JSON.parse(JSON.stringify({ tubes: tubes, moves: moves }))
          );
          if (history.length > 50) history.shift();
        }
      }

      function undoMove() {
        // (Code unchanged)
        if (
          solvabilityMessageDiv.style.display === "block" ||
          gameWon ||
          history.length <= 1
        )
          return;
        history.pop();
        const previousState = history[history.length - 1];
        tubes = JSON.parse(JSON.stringify(previousState.tubes));
        moves = previousState.moves;
        selectedTubeIndex = -1;
        renderTubes();
        updateMovesDisplay();
        updateUndoButton();
        winMessageDiv.style.display = "none";
        gameWon = false;
      }

      function updateUndoButton() {
        // (Code unchanged)
        undoBtn.disabled =
          history.length <= 1 ||
          gameWon ||
          solvabilityMessageDiv.style.display === "block";
      }

      // --- Event Listeners ---
      restartBtn.addEventListener("click", restartGame);
      undoBtn.addEventListener("click", undoMove);
      newGameBtn.addEventListener("click", () => {
        initGame(difficultySelect.value, false); // false = do run BFS
      });
      difficultySelect.addEventListener("change", (event) => {
        initGame(event.target.value, false); // false = do run BFS
      });

      // --- Unit Testing Framework ---
      const testResults = { passed: 0, failed: 0 };

      function assertEquals(expected, actual, message) {
        // (Code unchanged)
        const expectedStr = JSON.stringify(expected);
        const actualStr = JSON.stringify(actual);
        if (expectedStr === actualStr) {
          testResults.passed++;
        } else {
          testResults.failed++;
          console.error(`FAIL: ${message}`);
          console.error(`  Expected: ${expectedStr}`);
          console.error(`  Actual:   ${actualStr}`);
        }
      }

      function assertTrue(actual, message) {
        // (Code unchanged)
        if (actual === true) {
          testResults.passed++;
        } else {
          testResults.failed++;
          console.error(`FAIL: ${message}`);
          console.error(`  Expected: true`);
          console.error(`  Actual:   ${actual}`);
        }
      }
      function assertFalse(actual, message) {
        // (Code unchanged)
        if (actual === false) {
          testResults.passed++;
        } else {
          testResults.failed++;
          console.error(`FAIL: ${message}`);
          console.error(`  Expected: false`);
          console.error(`  Actual:   ${actual}`);
        }
      }

      function runTests() {
        console.log("--- Running Unit Tests ---");
        testMode = true;
        const originalDifficulty = currentDifficulty;
        const originalTubes = JSON.parse(JSON.stringify(tubes));
        testResults.passed = 0; // Reset counts for each run
        testResults.failed = 0;

        // --- Tests --- (Sections unchanged, only specific states modified below)
        console.log("\nTesting getTopColorForState...");
        assertEquals(
          "red",
          getTopColorForState(["blue", "red"]),
          "getTopColor: Should get top color"
        );
        assertEquals(
          "blue",
          getTopColorForState(["blue"]),
          "getTopColor: Should get only color"
        );
        assertEquals(
          null,
          getTopColorForState([]),
          "getTopColor: Should get null for empty tube"
        );

        console.log("\nTesting canPourState...");
        assertTrue(canPourState(["red"], []), "canPour: Into empty");
        assertTrue(canPourState(["red"], ["red"]), "canPour: Onto same color");
        assertFalse(
          canPourState(["red"], ["blue"]),
          "canPour: Onto different color"
        );
        assertFalse(canPourState([], ["blue"]), "canPour: From empty");
        assertFalse(
          canPourState(["red"], ["red", "red", "red", "red"]),
          "canPour: Into full (C4)"
        );
        assertTrue(
          canPourState(["blue", "red"], ["red"]),
          "canPour: Red onto red (blue below)"
        );

        console.log("\nTesting createNextState...");
        let state1 = [["red"], ["blue"], []];
        let expectedState1 = [["red"], [], ["blue"]];
        let nextState1 = createNextState(state1, 1, 2);
        assertEquals(expectedState1, nextState1, "createNext: Simple pour");
        assertEquals(
          [["red"], ["blue"], []],
          state1,
          "createNext: Original unchanged"
        );

        let state2 = [["red", "red"], ["blue"], []];
        let expectedState2 = [[], ["blue"], ["red", "red"]];
        let nextState2 = createNextState(state2, 0, 2);
        assertEquals(
          expectedState2,
          nextState2,
          "createNext: Multi-block pour"
        );

        let state3 = [["blue", "red", "red"], ["red"], []];
        let expectedState3 = [["blue"], ["red"], ["red", "red"]];
        let nextState3 = createNextState(state3, 0, 2);
        assertEquals(
          expectedState3,
          nextState3,
          "createNext: Contiguous top only"
        );

        let state4 = [["red"], ["blue", "blue", "blue"], []];
        let expectedState4 = [[], ["blue", "blue", "blue"], ["red"]];
        let nextState4 = createNextState(state4, 0, 2);
        assertEquals(
          expectedState4,
          nextState4,
          "createNext: Limited by space"
        );

        console.log("\nTesting checkWinConditionForState...");
        let winState = [
          ["red", "red", "red", "red"],
          ["blue", "blue", "blue", "blue"],
          [],
        ];
        let notWinState1 = [
          ["red", "red", "red", "blue"],
          ["blue", "blue", "blue", "red"],
          [],
        ];
        let notWinState2 = [
          ["red", "red", "red"],
          ["blue", "blue", "blue", "blue"],
          ["red"],
        ];
        let winStatePartial = [["red", "red", "red", "red"], [], []];
        assertTrue(
          checkWinConditionForState(winState),
          "winCheck: Detects win state"
        );
        assertFalse(
          checkWinConditionForState(notWinState1),
          "winCheck: Detects mixed full tube"
        );
        assertFalse(
          checkWinConditionForState(notWinState2),
          "winCheck: Detects partially full tube"
        );
        assertTrue(
          checkWinConditionForState(winStatePartial),
          "winCheck: Counts partial solve as win"
        );

        console.log("\nTesting stringifyState...");
        let s1 = [["red"], ["blue"]];
        let s2 = [["red"], ["blue"]];
        let s3 = [["blue"], ["red"]];
        assertEquals(
          stringifyState(s1),
          stringifyState(s2),
          "stringify: Identical states match"
        );
        assertTrue(
          stringifyState(s1) !== stringifyState(s3),
          "stringify: Different states differ"
        );

        console.log("\nTesting checkBasicSolvability...");
        // Note: Internal console.errors from checkBasicSolvability are expected for the failing cases below.
        const testDifficultyName = "test-2color";
        DIFFICULTY_SETTINGS[testDifficultyName] = { colors: 2 };
        currentDifficulty = testDifficultyName;
        let validBasicState = [
          ["red", "red", "blue", "blue"],
          ["red", "red", "blue", "blue"],
          [],
          [],
        ]; // 8 blocks total
        let invalidCount = [
          ["red", "red", "blue", "blue"],
          ["red", "blue", "blue", "blue"],
          [],
          [],
        ]; // 3 red, 5 blue
        let invalidExtra = [
          ["red", "red", "blue", "blue"],
          ["red", "red", "blue", "green"],
          [],
          [],
        ]; // has green
        let invalidTotal = [
          ["red", "red", "blue"],
          ["red", "red", "blue", "blue"],
          [],
          [],
        ]; // 7 blocks
        tubes = validBasicState;
        assertTrue(
          checkBasicSolvability().solvable,
          "basicCheck: Valid 2-color"
        );
        tubes = invalidCount;
        assertFalse(
          checkBasicSolvability().solvable,
          "basicCheck: Invalid count (2c)"
        );
        tubes = invalidExtra;
        assertFalse(
          checkBasicSolvability().solvable,
          "basicCheck: Unexpected color (2c)"
        );
        tubes = invalidTotal;
        assertFalse(
          checkBasicSolvability().solvable,
          "basicCheck: Wrong total (2c)"
        );
        delete DIFFICULTY_SETTINGS[testDifficultyName];
        tubes = []; // Clear global tubes

        console.log("\nTesting isSolvableBFS...");
        // ** CORRECTED BFS TEST STATES (Capacity 4) **

        // Solvable: 2 colors, 8 blocks. Requires swaps.
        let simpleSolvable_c4_v2 = [
          ["red", "red", "red", "blue"], // Tube 0
          ["blue", "blue", "blue", "red"], // Tube 1
          [], // Tube 2
          [], // Tube 3
        ];
        assertTrue(
          isSolvableBFS(simpleSolvable_c4_v2),
          "BFS: Solvable simple C4 state"
        );

        // Unsolvable: 2 colors, 8 blocks. Trapped colors.
        let simpleUnsolvable_c4_v2 = [
          ["red", "blue", "red", "blue"], // Tube 0
          ["blue", "red", "blue", "red"], // Tube 1
          [], // Tube 2
          [], // Tube 3
        ];

        assertTrue(
          isSolvableBFS(simpleUnsolvable_c4_v2),
          "BFS: Solvable checkerboard C4 state"
        );

        // Solvable: 3 colors, 12 blocks. Needs 5 tubes total.
        let complexSolvable_c4_v2 = [
          ["blue", "red", "green", "red"], // T0: 4 blocks
          ["green", "blue", "red", "blue"], // T1: 4 blocks
          ["green", "blue", "green", "red"], // T2: 4 blocks
          [], // T3
          [], // T4
        ]; // Total 12 blocks, 3 colors. Looks solvable.
        // Context setting isn't strictly needed for BFS itself, but good practice
        const test3ColorName = "test-3color";
        DIFFICULTY_SETTINGS[test3ColorName] = { colors: 3 };
        currentDifficulty = test3ColorName;
        assertTrue(
          isSolvableBFS(complexSolvable_c4_v2),
          "BFS: Solvable complex C4 state"
        );
        delete DIFFICULTY_SETTINGS[test3ColorName];

        // --- Test Summary ---
        console.log("\n--- Test Summary ---");
        console.log(`Passed: ${testResults.passed}`);
        console.log(`Failed: ${testResults.failed}`);
        if (testResults.failed > 0) {
          console.error("!!! SOME UNIT TESTS FAILED !!!");
        } else {
          console.log("All unit tests passed successfully.");
        }
        console.log("----------------------");

        // Restore original state
        testMode = false;
        currentDifficulty = originalDifficulty;
        tubes = originalTubes; // Restore tubes to what they were before tests
        // Optional: Re-render if tests modified the displayed state
        // renderTubes();
      }

      // --- Initial Game Load ---
      window.onload = () => {
        const skipBFSonLoad = false;
        initGame(difficultySelect.value, skipBFSonLoad);
        if (window.location.hash === "#test") {
          //runTests();
        }

        // PWA Service Worker Registration (Ignoring errors as requested)
        if ("serviceWorker" in navigator) {
          navigator.serviceWorker
            .register("./sw.js")
            .then((reg) => console.log("Service Worker registered:", reg))
            .catch((err) =>
              console.log(
                "SW registration failed (ignore if expected):",
                err.message
              )
            );
        } else {
          console.log("Service Worker not supported.");
        }
      };
    </script>
  </body>
</html>
