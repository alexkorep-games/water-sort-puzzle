<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Color Liquid Sort Puzzle - Shuffled</title>
    <style>
      :root {
        --tube-width: 60px;
        --tube-height: 240px;
        --liquid-height: 60px; /* --tube-height / capacity */
        --tube-border-radius: 10px;
        --tube-bottom-radius: 30px;
        --animation-speed: 0.3s;
      }

      body {
        font-family: sans-serif;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        background-color: #f0f0f0;
        margin: 0;
        padding: 20px;
        box-sizing: border-box;
        background: linear-gradient(
          135deg,
          #6e8efb,
          #a777e3
        ); /* Calming gradient */
      }

      .game-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px;
        background-color: rgba(255, 255, 255, 0.1);
        border-radius: 15px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        max-width: 95%;
      }

      .game-info {
        display: flex;
        justify-content: space-between; /* Space out elements */
        width: 100%;
        max-width: 600px; /* Limit width of info bar */
        margin-bottom: 20px;
        color: white;
        font-size: 1.2em;
        font-weight: bold;
        padding: 0 10px;
        flex-wrap: wrap; /* Allow wrapping if space is tight */
        gap: 10px; /* Add gap between info items */
      }

      /* Style for individual info items */
      .info-item {
        flex: 1; /* Allow items to grow */
        min-width: 100px; /* Minimum width before wrapping */
        text-align: center; /* Center text within item */
      }
      /* Ensure target moves takes adequate space */
      #targetMoves {
        flex-grow: 1.5; /* Give slightly more space */
      }

      .tubes-container {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 20px;
        margin-bottom: 20px;
        padding: 10px;
        max-width: 100%;
      }

      .tube {
        width: var(--tube-width);
        height: var(--tube-height);
        border: 3px solid #ccc;
        border-bottom-left-radius: var(--tube-bottom-radius);
        border-bottom-right-radius: var(--tube-bottom-radius);
        border-top-left-radius: var(--tube-border-radius);
        border-top-right-radius: var(--tube-border-radius);
        background-color: rgba(255, 255, 255, 0.3);
        position: relative;
        overflow: hidden;
        cursor: pointer;
        transition: transform var(--animation-speed) ease,
          box-shadow var(--animation-speed) ease;
        display: flex;
        flex-direction: column-reverse; /* Stack liquids from bottom */
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      }

      .tube.selected {
        transform: translateY(-15px) scale(1.05);
        border-color: #ffeb3b; /* Yellow highlight */
        box-shadow: 0 6px 15px rgba(255, 235, 59, 0.5);
      }

      .liquid {
        width: 100%;
        height: var(--liquid-height);
        transition: background-color var(--animation-speed) ease,
          height var(--animation-speed) ease;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 0.7em; /* Just for debugging color names if needed */
        color: white;
        text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
      }

      .controls {
        display: flex;
        gap: 15px;
        margin-top: 10px;
        align-items: center; /* Align items vertically */
        flex-wrap: wrap; /* Allow buttons to wrap */
        justify-content: center; /* Center buttons when wrapped */
      }

      button {
        padding: 10px 20px;
        font-size: 1em;
        cursor: pointer;
        border: none;
        border-radius: 8px;
        background-color: #8e44ad;
        color: white;
        transition: background-color 0.2s ease, transform 0.1s ease;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        margin-bottom: 5px; /* Add space below buttons if they wrap */
      }

      button:hover {
        background-color: #9b59b6;
      }
      button:active {
        transform: scale(0.95);
      }
      button:disabled {
        background-color: #bdc3c7;
        cursor: not-allowed;
      }

      .win-message {
        position: fixed; /* Use fixed to overlay */
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(0, 180, 0, 0.9);
        color: white;
        padding: 30px 50px;
        border-radius: 15px;
        font-size: 2em;
        font-weight: bold;
        text-align: center;
        z-index: 1000;
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        animation: fadeIn 0.5s ease-out;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translate(-50%, -60%);
        }
        to {
          opacity: 1;
          transform: translate(-50%, -50%);
        }
      }

      /* Basic responsiveness */
      @media (max-width: 600px) {
        :root {
          --tube-width: 50px;
          --tube-height: 200px;
          --liquid-height: 50px;
        }
        .game-info {
          font-size: 1em;
          justify-content: center; /* Center info items on smaller screens */
        }
        .info-item {
          min-width: 80px; /* Adjust min-width */
        }
        .win-message {
          font-size: 1.5em;
          padding: 20px 30px;
        }
      }
      @media (max-width: 400px) {
        :root {
          --tube-width: 45px;
          --tube-height: 180px;
          --liquid-height: 45px;
        }
        .tubes-container {
          gap: 15px;
        }
        .game-info {
          font-size: 0.9em;
        }
      }
    </style>
  </head>
  <body>
    <div class="game-container">
      <div class="game-info">
        <!-- Updated Info Area -->
        <span class="info-item" id="targetMoves">Target: 0</span>
        <span class="info-item" id="moves">Moves: 0</span>
      </div>
      <div class="tubes-container" id="tubesContainer">
        <!-- Tubes will be generated here by JavaScript -->
      </div>
      <div class="controls">
        <!-- Removed Level Selector -->
        <button id="undoBtn">Undo</button>
        <button id="restartBtn">Restart</button>
        <!-- Added New Game Button -->
        <button id="newGameBtn">New Game</button>
      </div>
      <div id="winMessage" class="win-message" style="display: none">
        Solved! ðŸŽ‰
      </div>
    </div>

    <script>
      const tubesContainer = document.getElementById("tubesContainer");
      const movesSpan = document.getElementById("moves");
      const targetMovesSpan = document.getElementById("targetMoves"); // New element reference
      const undoBtn = document.getElementById("undoBtn");
      const restartBtn = document.getElementById("restartBtn");
      const newGameBtn = document.getElementById("newGameBtn"); // New element reference
      const winMessageDiv = document.getElementById("winMessage");

      const TUBE_CAPACITY = 4;
      const COLORS = {
        red: "#e74c3c",
        blue: "#3498db",
        green: "#2ecc71",
        yellow: "#f1c40f",
        purple: "#9b59b6",
        orange: "#e67e22",
        pink: "#fd79a8",
        cyan: "#00cec9",
        lime: "#a2e041", // Added more colors
        brown: "#8b4513",
        gray: "#808080",
        teal: "#008080",
      };
      const COLOR_NAMES = Object.keys(COLORS);
      const NUM_EMPTY_TUBES = 2; // Typically 2 empty tubes

      // --- Difficulty Settings ---
      const DIFFICULTY_SETTINGS = {
        // numColors, numShuffles
        easy: { colors: 4, shuffles: 15 },
        medium: { colors: 6, shuffles: 30 },
        hard: { colors: 8, shuffles: 50 },
        expert: { colors: 10, shuffles: 75 },
      };
      let currentDifficulty = "medium"; // Default difficulty

      let tubes = []; // Array of arrays, representing tubes and their colors bottom-to-top
      let currentGameInitialState = []; // To store the state for the restart button
      let targetMoves = 0; // Target moves based on shuffling
      let selectedTubeIndex = -1;
      let moves = 0;
      let history = []; // To store game states for undo
      let gameWon = false;

      // --- Core Game Logic ---

      function getRandomInt(min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min) + min); // The maximum is exclusive and the minimum is inclusive
      }

      /**
       * Generates a random initial state by shuffling a solved state.
       * Moves only ONE block per successful shuffle step.
       * @param {number} numColors - Number of distinct colors to use.
       * @param {number} numEmpty - Number of empty tubes.
       * @param {number} shuffleCount - Number of random pour attempts to make.
       * @returns {{initialState: Array<Array<string>>, targetMoves: number}}
       */
      function generateRandomInitialState(numColors, numEmpty, shuffleCount) {
        if (numColors > COLOR_NAMES.length) {
          console.warn(
            `Requested ${numColors} colors, but only ${COLOR_NAMES.length} are defined. Using ${COLOR_NAMES.length}.`
          );
          numColors = COLOR_NAMES.length;
        }
        const totalTubes = numColors + numEmpty;
        const availableColors = COLOR_NAMES.slice(0, numColors);

        // 1. Create the solved state
        let solvedState = [];
        for (const color of availableColors) {
          const fullTube = Array(TUBE_CAPACITY).fill(color);
          solvedState.push(fullTube);
        }
        for (let i = 0; i < numEmpty; i++) {
          solvedState.push([]); // Add empty tubes
        }

        // 2. Shuffle the solved state using random valid SINGLE BLOCK moves (backward)
        let shuffledState = JSON.parse(JSON.stringify(solvedState)); // Deep copy to modify
        let actualShuffles = 0;
        let attempts = 0; // Prevent infinite loop
        // Increase maxAttempts slightly, as valid moves are now more frequent
        const maxAttempts = shuffleCount * 5; // Can likely be lower now, but keep it safe

        while (actualShuffles < shuffleCount && attempts < maxAttempts) {
          attempts++;
          const sourceIndex = getRandomInt(0, totalTubes);
          let destIndex = getRandomInt(0, totalTubes);
          // Ensure source and destination are different
          while (destIndex === sourceIndex) {
            destIndex = getRandomInt(0, totalTubes);
          }

          // Simulate pour on the *shuffledState*
          const sourceTube = shuffledState[sourceIndex];
          const destTube = shuffledState[destIndex];

          // Check if a SINGLE block pour is possible, IGNORING color matching.
          // We only care if the source has liquid and the destination has space.
          const canSimulatedPour =
            sourceTube.length > 0 && // Source must have liquid
            destTube.length < TUBE_CAPACITY; // Destination must have space

          if (canSimulatedPour) {
            // Perform the pour of ONLY ONE block
            const blockToMove = sourceTube.pop();
            destTube.push(blockToMove);

            actualShuffles++;
          }
        }
        if (attempts >= maxAttempts) {
          console.warn(
            `Reached max shuffle attempts (${maxAttempts}). Only ${actualShuffles} single-block shuffles performed.`
          );
        } else if (actualShuffles < shuffleCount && shuffleCount > 0) {
          // Avoid warning if shuffleCount is 0
          console.warn(
            `Could not perform all requested ${shuffleCount} shuffles. Only ${actualShuffles} were successful.`
          );
        }

        console.log(
          `Generated state with ${actualShuffles} random single-block shuffles (ignoring color match rule).`
        );

        // Optional check: Ensure the resulting state is not *already* solved.
        // Very unlikely now, but possible if shuffleCount is very low or unlucky.
        if (actualShuffles > 0 && isSolved(shuffledState)) {
          console.warn(
            "Shuffled state resulted in a solved state. Might need more shuffles for difficulty."
          );
          // If this happens often, you might regenerate or increase shuffleCount.
        }

        return { initialState: shuffledState, targetMoves: actualShuffles };
      }

      // Helper function to check if a state is solved (used by the optional check above)
      function isSolved(stateToCheck) {
        for (const tube of stateToCheck) {
          if (tube.length === 0) continue; // Empty tube is fine

          if (tube.length === TUBE_CAPACITY) {
            const firstColor = tube[0];
            for (let i = 1; i < tube.length; i++) {
              if (tube[i] !== firstColor) {
                return false; // Mixed colors in a full tube
              }
            }
          } else {
            return false; // Partially filled tube means not solved
          }
        }
        return true; // All tubes are empty or full with one color
      }
      function initGame(difficulty = currentDifficulty) {
        console.log(`Initializing Game - Difficulty: ${difficulty}`);
        currentDifficulty = difficulty; // Update current difficulty
        const settings =
          DIFFICULTY_SETTINGS[difficulty] || DIFFICULTY_SETTINGS.medium;

        // Generate the random state
        const { initialState, targetMoves: generatedTargetMoves } =
          generateRandomInitialState(
            settings.colors,
            NUM_EMPTY_TUBES,
            settings.shuffles
          );

        // Store the initial state for Restart
        currentGameInitialState = JSON.parse(JSON.stringify(initialState));
        targetMoves = generatedTargetMoves; // Store the target moves

        // Set the active game state
        tubes = JSON.parse(JSON.stringify(initialState));

        selectedTubeIndex = -1;
        moves = 0;
        history = []; // Clear history
        gameWon = false;
        winMessageDiv.style.display = "none"; // Hide win message

        updateMovesDisplay(); // Update moves count (0)
        updateTargetMovesDisplay(); // Update target moves display

        saveState(); // Save the initial state for undo
        renderTubes();
        updateUndoButton();
      }

      function restartGame() {
        console.log("Restarting current game.");
        if (currentGameInitialState.length === 0) {
          console.error("No initial state saved. Cannot restart.");
          initGame(); // Generate a new game if restart fails
          return;
        }
        // Restore the active state from the saved initial state
        tubes = JSON.parse(JSON.stringify(currentGameInitialState));

        // Reset game variables
        selectedTubeIndex = -1;
        moves = 0;
        history = []; // Clear history
        gameWon = false;
        winMessageDiv.style.display = "none";

        updateMovesDisplay(); // Reset moves display
        // Target moves remains the same for the current puzzle
        saveState(); // Save the restarted initial state for undo
        renderTubes();
        updateUndoButton();
      }

      function renderTubes() {
        tubesContainer.innerHTML = ""; // Clear previous tubes
        tubes.forEach((tubeData, index) => {
          const tubeElement = document.createElement("div");
          tubeElement.classList.add("tube");
          tubeElement.dataset.index = index; // Store index for click handling

          // Add liquids from bottom up
          tubeData.forEach((color) => {
            const liquidSegment = document.createElement("div");
            liquidSegment.classList.add("liquid");
            liquidSegment.style.backgroundColor = COLORS[color] || "#cccccc"; // Default color if not found
            tubeElement.appendChild(liquidSegment);
          });

          // Fill remaining space with transparent divs if needed (visual consistency)
          const emptySpaces = TUBE_CAPACITY - tubeData.length;
          for (let i = 0; i < emptySpaces; i++) {
            const emptySegment = document.createElement("div");
            emptySegment.classList.add("liquid");
            emptySegment.style.height = `var(--liquid-height)`;
            emptySegment.style.backgroundColor = "transparent"; // Make empty space clear
            // Prepend empty segments to push liquids down visually - NO, append is correct with flex-direction: column-reverse
            tubeElement.appendChild(emptySegment);
          }

          // Ensure correct visual height when tube is not full (should be handled by flexbox layout now)

          if (index === selectedTubeIndex) {
            tubeElement.classList.add("selected");
          }

          tubeElement.addEventListener("click", handleTubeClick);
          tubesContainer.appendChild(tubeElement);
        });
      }

      function handleTubeClick(event) {
        if (gameWon) return; // Don't allow moves after winning

        const clickedIndex = parseInt(event.currentTarget.dataset.index);

        if (selectedTubeIndex === -1) {
          // First click: Select source tube
          if (tubes[clickedIndex].length > 0) {
            // Can only select non-empty tubes
            selectedTubeIndex = clickedIndex;
            renderTubes(); // Re-render to show selection
          }
        } else {
          // Second click: Select destination tube or deselect
          if (clickedIndex === selectedTubeIndex) {
            // Clicked the same tube again: Deselect
            selectedTubeIndex = -1;
            renderTubes();
          } else {
            // Attempt to pour
            if (canPour(selectedTubeIndex, clickedIndex)) {
              saveState(); // Save state *before* making the move
              doPour(selectedTubeIndex, clickedIndex);
              moves++;
              updateMovesDisplay();
              selectedTubeIndex = -1; // Deselect after pour
              renderTubes();
              updateUndoButton(); // Update undo button state after move
              checkWinCondition();
            } else {
              // Invalid move - maybe add visual feedback later (e.g., shake)
              console.log("Invalid move");
              selectedTubeIndex = -1; // Deselect if move is invalid
              renderTubes(); // Re-render to remove selection highlight
            }
          }
        }
      }

      function getTopColor(tube) {
        return tube.length > 0 ? tube[tube.length - 1] : null;
      }

      function canPour(sourceIndex, destIndex) {
        const sourceTube = tubes[sourceIndex];
        const destTube = tubes[destIndex];

        if (sourceTube.length === 0) return false; // Cannot pour from empty tube
        if (destTube.length >= TUBE_CAPACITY) return false; // Cannot pour into full tube

        const topColorSource = getTopColor(sourceTube);
        const topColorDest = getTopColor(destTube);

        // Can pour if destination is empty OR top colors match
        return topColorDest === null || topColorSource === topColorDest;
      }

      function doPour(sourceIndex, destIndex) {
        const sourceTube = tubes[sourceIndex];
        const destTube = tubes[destIndex];
        const colorToMove = getTopColor(sourceTube);

        if (!colorToMove) return; // Should not happen if canPour is checked, but good practice

        // Find how many blocks of the same color are at the top of the source tube
        let pourAmount = 0;
        for (let i = sourceTube.length - 1; i >= 0; i--) {
          if (sourceTube[i] === colorToMove) {
            pourAmount++;
          } else {
            break; // Stop if a different color is encountered
          }
        }

        // Limit pour amount by available space in destination tube
        const availableSpace = TUBE_CAPACITY - destTube.length;
        pourAmount = Math.min(pourAmount, availableSpace);

        // Perform the transfer
        for (let i = 0; i < pourAmount; i++) {
          destTube.push(sourceTube.pop());
        }
      }

      function checkWinCondition() {
        if (gameWon) return; // Already won

        for (const tube of tubes) {
          if (tube.length > 0 && tube.length < TUBE_CAPACITY) {
            return; // Partially filled tube exists
          }
          if (tube.length === TUBE_CAPACITY) {
            const firstColor = tube[0];
            for (let i = 1; i < tube.length; i++) {
              if (tube[i] !== firstColor) {
                return; // Found a different color in a full tube
              }
            }
          }
          // Empty tubes (tube.length === 0) are fine
        }

        // If we reach here, all non-empty tubes are full of a single color
        console.log("Win condition met!");
        gameWon = true;
        winMessageDiv.textContent = `Solved in ${moves} moves!`; // Show moves count
        winMessageDiv.style.display = "block";
        updateUndoButton(); // Disable undo after winning

        // Optional: Automatically start a new game after a delay
        setTimeout(() => {
          // initGame(); // Start a new game of the same difficulty
          winMessageDiv.style.display = "none"; // Hide message after delay if not starting new game
        }, 3000); // Hide message/start new after 3 seconds
      }

      function updateMovesDisplay() {
        movesSpan.textContent = `Moves: ${moves}`;
      }

      // --- New function to update target moves display ---
      function updateTargetMovesDisplay() {
        targetMovesSpan.textContent = `Target: ${targetMoves}`;
      }

      // --- Undo Functionality ---

      function saveState() {
        // Save a deep copy of the current state
        history.push(
          JSON.parse(JSON.stringify({ tubes: tubes, moves: moves }))
        );
      }

      function undoMove() {
        if (gameWon) return; // Cannot undo after winning
        if (history.length > 1) {
          // Need at least the initial state + one move to undo
          history.pop(); // Remove the current state
          const previousState = history[history.length - 1]; // Get the state before the last move

          // Restore the previous state (deep copy)
          tubes = JSON.parse(JSON.stringify(previousState.tubes));
          moves = previousState.moves;

          selectedTubeIndex = -1; // Reset selection
          renderTubes();
          updateMovesDisplay();
          updateUndoButton();
          winMessageDiv.style.display = "none"; // Hide win message if it was shown erroneously
          gameWon = false; // Ensure game isn't marked as won
        } else {
          console.log("Cannot undo further.");
        }
      }

      function updateUndoButton() {
        undoBtn.disabled = history.length <= 1 || gameWon; // Disable if only initial state left or game won
      }

      // --- Event Listeners ---
      restartBtn.addEventListener("click", restartGame); // Use the new restart function
      undoBtn.addEventListener("click", undoMove);
      newGameBtn.addEventListener("click", () => initGame()); // New Game button calls initGame

      // --- Initial Game Load ---
      window.onload = () => {
        // Removed level selector population
        initGame(); // Initialize the game with default difficulty
      };
    </script>
  </body>
</html>
